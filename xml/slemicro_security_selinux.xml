<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "generic-entities.ent">
    %entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha-selinux-slemicro">
 <info>
  <title>SELinux</title>
  <abstract>
   <para>
    This chapter gives a brief overview of SELinux implementation on &slema;.
   </para>
  </abstract>
 </info>
 <para>
  SELinux was developed as an additional Linux security solution that uses the
  security framework in the Linux kernel. The purpose was to allow for a more
  granular security policy that goes beyond the standard Discretionary Access
  Controls (DAC), the traditional file permissions of owner/group/world, and
  read/write/execute.
 </para>
 <para>
  SELinux uses labels attached to objects (for example, files and network
  sockets) and uses them for access decisions.
 </para>
 <para>
  The default action of SELinux is to deny any access. SELinux allows only
  actions that were specifically allowed in the SELinux policy. Another feature
  of SELinux that increases security is that SELinux allows strict confinement
  of processes up to the point where the processes cannot access files of other
  processes on the same system.
 </para>
 <para>
  SELinux was designed to enhance existing security solutions, not to replace
  them. For example, discretionary access control (DAC) is still applied even
  if the system is using SELinux. If DAC denies access first, SELinux is then
  not used as the access was already blocked by another mechanism.
 </para>
 <section xml:id="sec-getting-selinux">
  <title>Getting SELinux</title>
  <para>
   SELinux is installed by default when installing &slema; by &yast; or is part
   of the pre-built images. The default mode is set to permissive on all
   deployment types, and the file system is labelled.
  </para>
  <para>
   To set the SELinux mode to <literal>enforcing</literal> and configure your
   system properly for using SELinux, run the following command:
  </para>
<screen>&prompt.root;transactional-update setup-selinux</screen>
  <para>
   Reboot your system after the command has finished. The command installs the
   SELinux policy if it is not installed, sets the <literal>enforcing</literal>
   SELinux mode and rebuilds <literal>initrd</literal>.
  </para>
 </section>
 <section xml:id="sec-switching-modes">
  <title>SELinux modes</title>
  <para>
   SELinux can run in one of three modes: <literal>disabled</literal>,
   <literal>permissive</literal>, or <literal>enforcing</literal>.
  </para>
  <para>
   Using the <literal>disabled</literal> mode means that no rules from the
   SELinux policy are applied and your system is not protected. Therefore, the
   <literal>disabled</literal> mode is not recommended.
  </para>
  <para>
   In the <literal>permissive</literal> mode, SELinux is active, the security
   policy is loaded, the file system is labeled and access denial entries are
   logged. However, the policy is not enforced and thus no access is actually
   denied.
  </para>
  <para>
   In the <literal>enforced</literal> mode, the security policy is applied.
   Each access that is not explicitly allowed by the policy is denied.
  </para>
  <para>
   You can switch between the <literal>enforcing</literal> and
   <literal>permissive</literal> modes by using the
   <command>setenforce</command> command. Alternatively, you can switch between
   all SELinux modes by editing the <filename>/etc/selinux/config</filename>
   configuration file. Changes performed by the <command>setenforce</command>
   command are valid only until the next reboot. For persistent changes of the
   SELinux mode, edit the <filename>/etc/selinux/config</filename>
   configuration file.
  </para>
  <para>
   The <command>setenforce</command> command has the following syntax:
  </para>
<screen>&prompt.root;setenforce <replaceable>MODE_ID</replaceable></screen>
  <para>
   where <replaceable>MODE_ID</replaceable> is <replaceable>0</replaceable> for
   the <literal>permissive</literal> mode or <replaceable>1</replaceable> for
   the <literal>enforced</literal> mode.
  </para>
  <para>
   To verify the mode, run the following command:
  </para>
<screen>&prompt.root;getenforce</screen>
  <para>
   The command should return <literal>Permissive</literal> or
   <literal>Enforced</literal>, depending on the provided
   <replaceable>MODE_ID</replaceable>.
  </para>
  <para>
   To change the SELinux mode permanently, in the file
   <filename>/etc/selinux/config</filename>, change the value of
   <literal>SELINUX</literal> to <literal>disabled</literal>, or
   <literal>permissive</literal>, or <literal>enforced</literal> as follows:
  </para>
<screen>SELINUX=disabled</screen>
  <para>
   The changes in the file are applied after the next reboot.
  </para>
  <note>
   <title>Relabeling your system after switching from the <literal>disabled</literal> mode</title>
   <para>
    If you disable SELinux on your system and then enable it later, make sure
    that you relabel your system. When SELinux is disabled, and you perform
    changes to your file system, the changes are not reflected in the context
    anymore (for example, new files do not have any context). Therefore, you
    need to relabel your system by using the <command>restorecon</command>
    command, using the <literal>autorelabel</literal> boot parameter, or by
    creating a file that will trigger relabeling on the next boot. To create
    the file, run the following command:
   </para>
<screen>&prompt.root;touch /etc/selinux/.autorelabel</screen>
   <para>
    After reboot, the file <filename>/etc/selinux/.autorelabel</filename> is
    replaced with another flag file:
    <filename>/etc/selinux/.relabelled</filename> to prevent relabeling on
    subsequent reboots.
   </para>
  </note>
 </section>
 <section xml:id="sec-policy-overview">
  <title>SELinux policy overview</title>
  <para>
   The policy is the key component in SELinux. Your SELinux policy defines
   rules that specify which objects can access which files, directories, ports,
   and processes on a system. To do this, a security context is defined for all
   of these.
  </para>
  <para>
   An SELinux policy contains a huge number of rules. To make it more
   manageable, policies are often split into modules. This allows the
   administrator to switch protection on or off for different parts of the
   system.
  </para>
  <para>
   When compiling the policy for your system, you will have a choice to either
   work with a modular policy, or a monolithic policy, where one huge policy is
   used to protect everything on your system. It is strongly recommended to use
   a modular policy and not a monolithic policy. Modular policies are much
   easier to manage.
  </para>
  <para>
   &slema; is shipped with the <literal>targeted</literal> SELinux policy.
  </para>
  <para>
    Part of the policy can be switched on or off by using booleans. For details, refer to <xref linkend="sec-selinux-booleans"/>.
  </para>

  <section xml:id="sec-policy-containers">
   <title>Creating policies for containers</title>
   <para>
    &productnameshort; is delivered with a policy that by default does not
    allow containers to access files outside of the container data. On the
    other hand, all network access is allowed. Typically, containers are
    created with bind mounts and should be able to access other directories
    like, for example, <filename>/home</filename> or <filename>/var</filename>.
    You may want a possibility to allow access to these directories or, on the
    contrary, restrict some ports to the container even if SELinux is used
    on your system. In this case, you need to create new policy rules that
    enable or disable the access. &productnameshort; provides the Udica tool for
    this purpose.
   </para>
   <para>
    The following procedure describes how to create a custom policy for your
    containers:
   </para>
   <procedure>
    <step>
     <para>
      Make sure that SELinux is in the enforcing mode. For details, refer to
      <xref linkend="sec-switching-modes"/>.
     </para>
    </step>
    <step>
     <para>
      Start a container using the following parameters:
     </para>
<screen>&prompt.root;podman run -v /home:/home:rw -v /var/:/var/:rw -p 21:21 -it ruby bash</screen>
     <para>
      The container runs with the default policy that does not allow access to
      the mount points but does not restrict other ports.
     </para>
    </step>
    <step>
     <para>
      You can exit the container.
     </para>
    </step>
    <step>
     <para>
      Obtain the container ID:
     </para>
<screen>&prompt.root;podman ps -a

CONTAINER ID  IMAGE                                                                              COMMAND     CREATED        STATUS            PORTS               NAMES
e59f9d0f86f2  registry.opensuse.org/devel/bci/tumbleweed/containerfile/opensuse/bci/ruby:latest  /bin/bash   8 minutes ago  Up 8 seconds ago  0.0.0.0:21->21/tcp  zen_ramanujan
        </screen>
    </step>
    <step>
     <para>
      Create a JSON file that Udica will use to create a custom policy for the
      container:
     </para>
<screen>&prompt.root;podman inspect e59f9d0f86f2 > <replaceable>OUTPUT_JSON_FILE</replaceable></screen>
     <para>
      For example, substitute <replaceable>OUTPUT_JSON_FILE</replaceable> with
      <filename>container.json</filename>
     </para>
    </step>
    <step>
     <para>
      Run Udica to generate a policy according to the container parameters:
     </para>
<screen>&prompt.root;udica -j <replaceable>OUTPUT_JSON_FILE</replaceable>  <replaceable>CUSTOM_CONTAINER_POLICY</replaceable></screen>
     <para>
      For example:
     </para>
<screen>&prompt.root;udica -j container.json custom_policy</screen>
    </step>
    <step>
     <para>
      According to the provided instructions, load the policy modules by
      running:
     </para>
<screen>&prompt.root;semodule -i custom_policy.cil /usr/share/udica/templates/{base_container.cil,net_container.cil,home_container.cil}</screen>
    </step>
    <step>
     <para>
      Run a container with the new policy module by using the
      <option>--security-opt</option> option as follows:
     </para>
<screen>&prompt.root;podman run --security-opt label=type:custom_policy.process -v /home:/home:rw -v /var/:/var/:rw -p 21:21 -it ruby bash</screen>
    </step>
   </procedure>
  </section>
 </section>

 <section xml:id="sec-selinux-booleans">
  <title>SELinux booleans</title>
  <para>
    The SELinux booleans supports a flexible policy management approach. Booleans enable you to, for example, disable a particular policy on one server, while keeping the same policy active on another one. In other words, a boolean can be understood as a switch of a policy rule. Intead of changing a particular policy, you can switch it off. In the policy code, booleans are called a <emphasis>tunable</emphasis>. With the booleans being included in the policy, they are available once a policy is loaded. 
  </para>
  <para>
    The changes to the booleans value may be persistent or just temporary till the session is ended.
  </para>
  
    <para>
    SELinux offers tools that enable you to list, view details or change the state of booleans. See the following sections for details.
    </para>
  
<section xml:id="sec-list-booleans">
  <title>Listing booleans</title>
  <para>
    You can use the <command>getsebool</command> or <command>semanage</command> command to list currently defined booleans. To list all currently defined booleans with their state, run the following command:
  </para>
  <screen>&prompt.root;getsebool -a

abrt_anon_write --> off
abrt_handle_event --> off
abrt_upload_watch_anon_write --> on
...
  </screen>
  <para>
    To get more details about particular booleans, you can use the <command>semanage</command> command as follows:
  </para>
  <screen>&prompt.root;semanage boolean -l

SELinux boolean               State   Default     Description

abrt_anon_write               (off  ,  off)       Allow abrt to anon write
abrt_handle_event             (off  ,  off)       Allow abrt to handle event
abrt_upload_watch_anon_write  (on   ,   on)       Allow abrt to upload watch anon write
  </screen>
  <para>
    To get the status of an individual boolean, you can use the following command:
  </para>
  <screen>&prompt.root;getsebool <replaceable>BOOLEAN_NAME</replaceable></screen>
  <para>
    Alternatively, you can just use the <command>grep</command> command on the <command>semanage boolean</command> output:
  </para>
  <screen>&prompt.root;semanage boolean -l | grep <replaceable>BOOLEAN_NAME</replaceable></screen>
  </section>

  <section xml:id="sec-switching-booleans">
    <title>Toggling booleans</title>
    <para>
    The commands <command>setsebool</command> and <command>semanage</command> can be used to toggle booleans value. You can change the boolean status persistently or just temporarily untill the session is ended. To change a boolean value temporarily, run the following command:
  </para>
  <screen>&prompt.root;setsebool <replaceable>BOOLEAN_NAME</replaceable> <replaceable>BOOLEAN_VALUE</replaceable></screen>
  <para>
    where <replaceable>BOOLEAN_VALUE</replaceable> is either <literal>on</literal> or <literal>off</literal>.
  </para>
  <para>
    To change a boolean value that persists, run one of the following two commands:
  </para>
  <screen>&prompt.root;setsebool -P <replaceable>BOOLEAN_NAME</replaceable> <replaceable>BOOLEAN_VALUE</replaceable></screen>
  <para>
    Alternatively, using the <command>semanage</command> command:
  </para>
  <screen>&prompt.root;semanage boolean -m --<replaceable>BOOLEAN_VALUE</replaceable>  <replaceable>BOOLEAN_NAME</replaceable></screen>
  <para>
    where <replaceable>BOOLEAN_VALUE</replaceable> is either <literal>on</literal> or <literal>off</literal>.
  </para>
  <para>
    A single boolean can enable or disable several policy rules. To view which policy rules are enabled or disabled by which booleans, use the <command>sedispol</command> tool that can parse the policy file:
  </para>
  <screen>&prompt.root;sedispol /etc/selinux/targeted/policy/policy.32</screen>
  <para>
    As the policy rules are usually huge, we recommend setting an output file by selecting the <option>f</option> and specifying a file name. After specifying the file name, press <option>6</option>, then you can inspect the file.
  </para>
  </section>

 </section>

 <section xml:id="sec-security-context">
  <title>SELinux security context</title>
  <para>
   The security context is a set of information assigned to a file or a
   process. It consists of SELinux user, role, type, level and category. This
   information is used to make access control decisions.
  </para>
  <variablelist>
   <title>SELinux context fields</title>
   <varlistentry>
    <term>SELinux user</term>
    <listitem>
     <para>
      is an identity defined in the policy that is authorized for a specific
      set of roles and for a specific <emphasis>level</emphasis> range. Each
      Linux user is mapped to an SELinux user. SELinux does not use the list of
      user accounts maintained by Linux in <filename>/etc/passwd</filename>,
      but uses its own database and mapping. By convention, the identity name
      is suffixed with <literal>_u</literal>, for example:
      <literal>user_u</literal>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>role</term>
    <listitem>
     <para>
      defines a set of permissions that a user can be granted. A role defines
      which <emphasis>types</emphasis> a user assigned to this role can access.
      By convention, the role name is suffixed with <literal>_r</literal>, for
      example: <literal>system_r</literal>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>type</term>
    <listitem>
     <para>
      conveys information on how particular files and processes can interact. A
      process consists of files with a concrete SELinux type, and it cannot
      access files outside of this type. By convention, the type name is
      suffixed with <literal>_t</literal>, for example:
      <literal>var_t</literal>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>level</term>
    <listitem>
     <para>
      is an optional attribute that specifies the range of levels of clearance
      in the multilevel security.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>category</term>
    <listitem>
     <para>
      is an optional attribute that allows you to add categories to processes,
      files, and users. A user can then access files that have the same
      category.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

<section xml:id="sec-context-type">
  <title>The type context field</title>
</section>

 </section>

 <section xml:id="sec-managing-modes">
  <title>Tools for managing SELinux</title>
  <para>
   &slema; provides you with tools to manage SELinux on your system. If, in any
   case, the below described tools are not installed on your system, install
   the tools by running:
  </para>
<screen>&prompt.root;transactional-update pkg install policycoreutils-python-utils</screen>
  <para>
   After successful installation, reboot the system.
  </para>

  <section xml:id="sec-chcon-command">
    <title>The <command>chcon</command> command</title>
    <para>
      The command name <command>chcon</command> stands for change context. The command can change the full security context of a file to the value provided on the CLI, or it can change parts of the context. Alternatively, you can provide a file that serves as a reference.
    </para>
    <para>
      To change the full security context of a file, the command syntax looks as follows:
    </para>
    <screen>&prompt.root;chcon <replaceable>SECURITY_CONTEXT</replaceable> <replaceable>FILENAME</replaceable></screen>
    <para>
      where: 
    </para>
<itemizedlist>
  <listitem>
    <para>
      <replaceable>SECURITY_CONTEXT</replaceable> is in the format: <replaceable>SELinux_USER</replaceable>:<replaceable>ROLE</replaceable>:<replaceable>TYPE</replaceable>:<replaceable>LEVEL</replaceable>:<replaceable>CATEGORY</replaceable>. For example, the context could be: <emphasis>system_u:object_r:httpd_config_t:s0</emphasis>.
    </para>
  </listitem>
  <listitem>
  <para>
    <replaceable>FILENAME</replaceable> is a path to the file, which context should be changed.
  </para>
  </listitem>
</itemizedlist>    

<para>
  To set a security context according to a provided file that serves as a refence, run the <command>chcon</command> as follows:
  </para>
  <screen>&prompt.root;chcon --reference=<replaceable>REFERENCE_FILE</replaceable> <replaceable>FILENAME</replaceable></screen>
  <para>
    where:
  </para>
  <itemizedlist>
    <listitem>
    <para> 
      <replaceable>REFERENCE_FILE</replaceable> is a path to a file that should be used as a reference.
    </para>
  </listitem>
  <listitem>
  <para>
    <replaceable>FILENAME</replaceable> is a path to the file, which context should be changed.
  </para>
  </listitem>
</itemizedlist>
  <para>
    Alternatively, you can change only one part of the security context. The general syntax of the <command>chcon</command> command is as follows:
  </para>
  <screen>&prompt.root;chcon <replaceable>CONTEXT_OPTION</replaceable> <replaceable>CONTEXT_PART</replaceable> <replaceable>FILENAME</replaceable></screen>
  <para>
    where the options and arguments have the following meaning:
  </para>
  <itemizedlist>
    <listitem>
      <para>
        depending on the context part, <replaceable>CONTEXT_OPTION</replaceable> can be any of the following:
      </para>
      <variablelist>
        <varlistentry>
        <term><option>-u</option> resp <option>--user</option></term>
        <listitem>
          <para>
            denotes that a SELinux user context will be changed on the provided file:
          </para>
          <screen>&prompt.root;chcon -u system_u logind.conf</screen>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><option>-r</option> resp <option>--role</option></term>
        <listitem>
          <para>
            only the role part will be changed in the context of the provided file:
          </para>
          <screen>&prompt.root;chcon -r object_r logind.conf</screen>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><option>-t</option> resp <option>--type</option></term>
        <listitem>
          <para>
            only the type part will be changed in the context of the provided file:
          </para>
          <screen>&prompt.root;chcon -t etc_t logind.conf</screen>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><option>-l</option> resp <option>--range</option></term>
        <listitem>
          <para>
            only the range part of the security context will be changed:
          </para>
          <screen>&prompt.root;chcon -l s0 logind.conf</screen>
        </listitem>
      </varlistentry>
      
      </variablelist>
    </listitem>
    <listitem>
      <para>
        <replaceable>CONTEXT_PART</replaceable> is the particular value of the security context to be set.
      </para>
    </listitem>
    <listitem>
      <para>
        <replaceable>FILENAME</replaceable> is a path to the file which context will be changed.
      </para>
    </listitem>
  </itemizedlist>
  <note>
    <title>Using <command>chcon</command> on symbolic links</title>
    <para>
      By default, when you change the security context on a symbolic link, the context of the link target is changed and the symmbolic link context is <emphasis role="bold">not</emphasis> changed. To force <command>chcon</command> to change the context of the symbolic link and not the link target, use the <option>--no-dereference</option> option as shown below:
    </para>
    <screen>&prompt.root;chcon --no-dereference -u system_u -t etc_t network.conf</screen>
  </note>

  <para>
    You can change the context of all files in a directory by using the recursive option:
  </para>
  <screen>&prompt.root;chcon --recursive  system_u:object_r:httpd_config_t:s0 conf.d</screen>
  </section>

  <section xml:id="sec-getenforce-setenforce">
    <title><command>getenforce</command> and <command>setenforce</command> commands</title>
    <para>
      The <command>getenforce</command> returns the current SELinux mode: <literal>Enforcing</literal>, <literal>Permissive</literal>, or <literal>Disabled</literal>.
    </para>
    <screen>&prompt.root;getenforce

Permissive
    </screen>
    <para>
      The <command>setenforce</command> temporarily changes the SELinux mode to enforcing or permissive. You cannot use this command to disable SELinux. Bear in mind that the change persists only untill the next reboot. To change the state permanently, follow the description in <xref linkend="sec-switching-modes"/>.
    </para>
    <screen>&prompt.root;setenforce <replaceable>MODE_ID</replaceable></screen>
  <para>
   where <replaceable>MODE_ID</replaceable> is <replaceable>0</replaceable> for
   the <literal>permissive</literal> mode or <replaceable>1</replaceable> for
   the <literal>enforced</literal> mode.
  </para>
  </section>

  <section xml:id="sec-fixfiles-command">
    <title>The <command>fixfiles</command> script</title>
    <para>
      The script enables you to perform the following task with the security context:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          check if the context is correct 
        </para>
      </listitem>
      <listitem>
        <para>
          change any incorrect file context labels
        </para>
      </listitem>
      <listitem>
        <para>
          relabel your system if you added a new policy.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      The script syntax is as follows:
    </para>
    <screen>&prompt.root;fixfiles <replaceable>OPTIONS</replaceable> <replaceable>ARGUMENT</replaceable></screen>
    <para>
      TBD
    </para>
  </section>

  <section xml:id="sec-semanage-command">
    <title>The <command>semanage</command> command</title>
    <para>
      The <command>semanage</command> command can be used to configure parts of the policy without the need to recompile the policy from sources. The command enables you to perform the following tasks:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          manage booleans by using the <option>boolean</option> argument. For details about booleans, refer to <xref linkend="sec-selinux-booleans"/>.
        </para>
      </listitem>
      <listitem>
        <para>
          adjust the context of files by using the <option>fcontext</option> argument
        </para>
      </listitem>
      <listitem>
        <para>
          manage user mappings using the <option>login</option> argument
        </para>
      </listitem>
      <listitem>
        <para>
          manage SELinux users using the <option>user</option> option
        </para>
      </listitem>
      <listitem>
        <para>
          manage SELinux policy modules using the <option>module</option>
        </para>
      </listitem>
    </itemizedlist>
    <para>
      All of the above mentioned commands take several common options, listed below:
    </para>
    <variablelist>
      <varlistentry>
        <term><option>-l</option> or <option>--list</option></term>
        <listitem>
          <para>
            lists all objects.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>


<section xml:id="sec-semanage-fcontext">
  <title>The <command>semanage fcontext</command> command</title>
  <para>
    Using the <command>semanage fcontext</command> you can perform the following tasks:
  </para>
  <itemizedlist>
    <listitem>
      <para>
        query file context definitions
      </para>
    </listitem>
    <listitem>
      <para>
        add contexts on files
      </para>
    </listitem>
    <listitem>
      <para>
        add your own rules.
      </para>
    </listitem>
  </itemizedlist>
  <para>
    Changes performed to the file context using the <command>semanage fcontext</command> command does not require modifications or recompilation of the policy. 
  </para>

  <secton xml:id="sec-query-context">
    <title>Querying file context definitions</title>
    <para>
      You can view all file context definitions by running the command:
    </para>
    <screen>&prompt.root;semanage fcontext -l</screen>
<para>
  The command uses data stored in <filename>/etc/selinux/targeted/contexts/files/</filename> as a source of information.
</para>
  </secton>

  <section xml:id="sec-apply-context">
    <title>Adding contexts on files</title>
    <para>
      Any modification to a file context performed by the <command>semanage command</command> are stored in the <filename>/etc/selinux/targeted/contexts/files/file_contexts.local</filename>. File context definitions specified this way has a a higher priority than the definitions in policy modules.
    </para>
    <para>
      When specifying files which file context should be modified, you can provide a full path or you can use PERL regular expressions. For example, to add the <literal>httpd_sys_content_t</literal> type to all files in the <filename>/web</filename> directory, run the <command>semanage fcontext</command> command as follows:
    </para>
    <sceen>&prompt.root;semanage fcontext -a -t httpd_sys_content_t "/web(/.*)?"</sceen>
    <para>
      After adding the context, run the <command>restorecon</command> command:
    </para>
    <screen>&prompt.root;restorecon -R -v /web</screen>
   </section>
</section>
  </section>

  <section xml:id="sec-semanage-user">
    <title>The <command>semanage user</command> command</title>
    <para>
      The <command>semanage user</command> command enables you to manage SELinux users roles, MCS levels and ranges.
    </para>
    <para>
      To list current SELinux users on your system, run:
    </para>
    <screen>&prompt.root;semanage user -l

Labeling   MLS/       MLS/                          
SELinux User    Prefix     MCS Level  MCS Range                      SELinux Roles

guest_u         user       s0         s0                             guest_r
root            user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r
staff_u         user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r
sysadm_u        user       s0         s0-s0:c0.c1023                 sysadm_r
system_u        user       s0         s0-s0:c0.c1023                 system_r unconfined_r
unconfined_u    user       s0         s0-s0:c0.c1023                 system_r unconfined_r
user_u          user       s0         s0                             user_r
xguest_u        user       s0         s0                             xguest_r
    </screen>

    <para>
      The following command creates a user <literal>tux_u</literal> and assigns the <literal>sysadmin_r</literal> role to the user:
    </para>
    <screen>&prompt.root;semanage user -a -R "sysadmin_r" -r s0-s0:c0.c100,c201 tux_u</screen>

    <para>
      To modify an existing SELinux user, use the <option>-m</option> option as follows:
    </para>
    <screen>&prompt.root;semanage user -m -R "staff_r dbadm_r webadm_r" tux_u</screen>
    <para>
      The command above change the roles of the <literal>tux_u</literal> user to <literal>staff_r dbadm_r webadm_r</literal>.
    </para>
    <para>
      You can use the <command>semanage user</command> command to remove a custom SELinux user (SELinux users defined in policy cannot be deleted). Make sure that all mapping towards this SELinux user is updated before you remove the user. 
    </para>
    <screen>&prompt.root;semanage user -d tux_u</screen>
    <para>
      After deleting the SELinux user, relabel all resources that might be related to the user.
    </para>
  </section>
</section>

<section xml:id="sec-semanage-login">
  <title>The <command>semanage login</command> command</title>
  <para>
    The <command>semanage login</command> controls the mapping of users to SELinux users.
  </para>
  <para>
To list all users in the system, run:
  </para>
  <screen>&prompt.root;semanage login --list

Login Name           SELinux User         MLS/MCS Range        Service

__default__          unconfined_u         s0-s0:c0.c1023       *
root                 unconfined_u         s0-s0:c0.c1023       *
  </screen>
  <para>
    After you create a new user in the system, the user receives a default mapping - <literal>unconfined_u </literal>. You can change this default mapping using the <command>semanage login</command> command as follows. For example, to set the <literal>user_u</literal> SELinux user as default:
  </para>
  <screen>&prompt.root;semanage login -m -s user_u -r s0 __default__</screen>
  <para>
    The MLS range must be adjusted in this case as the <literal>user_u</literal> SELinux user cannot access the same MLS range as <literal>unconfined_u</literal>.
  </para>
  <para>
    Bear in mind that the new security context is not used until the user session is restarted. To use the new context, reboot the system. 
  </para>
  <para>
    If you want to change assigned SELinux user to an account, run the following command. 
  </para>
  <screen>&prompt.root;semanage login -a -s <replaceable>SELINUX_USER</replaceable> <replaceable>LOGIN_NAME</replaceable></screen>
  <para>
    For example, you can map the <literal>staff_u</literal> SELinux user on the <literal>tux</literal> user:
  </para>
  <screen>&prompt.root;semanage login -a -s staff_u tux</screen>

  </section>

<section xml:id="sec-restorecon-command">
  <title>The <command>restorecon</command> command</title>
</section>

  
   <varlistentry>
    <term><command>fixfiles</command></term>
    <listitem>
     <para>
      enables you to check for issues with a mismatched security context and
      then fix them
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>ls -Z <replaceable>PATH</replaceable></command></term>
    <listitem>
     <para>
      shows security context of all files/directories in the specified
      <replaceable>PATH</replaceable>, for example:
     </para>
<screen>&prompt.root;ls -Z /
system_u:object_r:bin_t:s0 bin
system_u:object_r:boot_t:s0 boot
system_u:object_r:device_t:s0 dev
system_u:object_r:etc_t:s0  etc
system_u:object_r:home_root_t:s0 home
system_u:object_r:lib_t:s0 lib
system_u:object_r:lib_t:s0 lib64
system_u:object_r:mnt_t:s0 mnt
system_u:object_r:usr_t:s0 opt
system_u:object_r:proc_t:s0 proc
system_u:object_r:default_t:s0 root
system_u:object_r:var_run_t:s0 run
system_u:object_r:bin_t:s0 sbin
system_u:object_r:var_t:s0 srv
system_u:object_r:sysfs_t:s0 sys
system_u:object_r:tmp_t:s0 tmp
system_u:object_r:usr_t:s0 usr
system_u:object_r:var_t:s0 var
          </screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>restorecon</command></term>
    <listitem>
     <para>
      restores a file context to the default value (as stored in the SELinux
      policy)
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>semanage</command></term>
    <listitem>
     <para>
      enables you to adjust context and configure certain elements of SELinux
      policy. The command provides several subcommands. For details, use:
     </para>
<screen>&prompt.root;semanage --help</screen>
    </listitem>
   </varlistentry>
   
   <varlistentry>
    <term><command>sestatus</command></term>
    <listitem>
     <para>
      displays the current status of SELinux, for example:
     </para>
<screen>&prompt.root;sestatus

SELinux status:               enabled
SElinuxfs mount:              /sys/fs/selinux
SELinux root directory:       /etc/selinux
Loaded policy name:           targeted
Current mode:                 enforcing
Mode from config file:        enforcing
Policy MLS status:            enabled
Policy deny_unknown status:   allowed
Memory protection checking:   requested (insecure)
Max kernel policy version:    31            
          </screen>
    </listitem>
   </varlistentry>
  </variablelist>
  <note>
   <title>The <literal>Z</literal> option available to other commands</title>
   <para>
    You can also use the <literal>Z</literal> option with other commands, for
    example: <command>cp, ps</command>, and <command>id</command>.
   </para>
  </note>
 </section>
</chapter>
