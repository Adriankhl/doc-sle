<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<!-- Converted by suse-upgrade version 1.1 -->
<!--
*********************************
Please see LICENSE.txt for this document's license.
*********************************
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:base="newbie_bash.xml" xml:id="cha.new.bash">
 <title>Shell-Grundlagen</title>
 <info/><indexterm>
 <primary>Shells </primary>
 <secondary>Grundlagen</secondary></indexterm>
 <para>
  Mittlerweile können Sie bei der Arbeit mit Linux mit dem System
  kommunizieren, nahezu ohne jemals einen Kommandozeileninterpreter (die Shell)
  zu benötigen. Nach dem Start des Linux-Systems wird in der Regel eine
  grafische Bedienoberfläche geöffnet, die Sie durch die Anmeldung und die
  darauf folgenden Interaktionen mit dem System führt. Die grafische
  Bedienoberfläche in Linux (X Window System oder X11) wird anfangs bei der
  Installation konfiguriert. Sowohl der KDE-Desktop als auch der GNOME-Desktop
  (und andere Fenstermanager, die Sie installieren können) verwenden sie zur
  Interaktion mit dem Benutzer.
 </para>
 <para>
  Dennoch sind Grundkenntnisse der Arbeit mit einer Shell nützlich, da Sie
  möglicherweise Situationen erleben, in denen die grafische Bedienoberfläche
  nicht verfügbar ist, etwa bei einem Problem mit dem X Window System. Wenn
  Sie nicht mit einer Shell vertraut sind, sind Sie anfangs bei der Eingabe von
  Kommandos möglicherweise etwas unsicher, aber je mehr Sie sich daran
  gewöhnen, um so mehr werden Sie erkennen, dass die Kommandozeile häufig die
  schnellste und einfachste Methode bietet, um einige alltägliche Aufgaben zu
  erledigen.
 </para>
 <para>
  Für UNIX oder Linux sind mehrere Shells verfügbar, die sich geringfügig in
  ihrem Verhalten und den akzeptierten Kommandos unterscheiden. Die
  Standard-Shell in &productnamereg; ist Bash (GNU Bourne-Again Shell).
 </para>
 <para>
  Die folgenden Abschnitte begleiten Sie durch Ihre ersten Schritte mit der
  Bash-Shell und zeigen Ihnen, wie Sie einige grundlegende Aufgaben über die
  Kommandozeile erledigen können. Wenn Sie mehr erfahren möchten oder sich
  bereits wie ein Shell-<quote>Powernutzer</quote> fühlen, siehe
  <xref linkend="cha.adm.shell"/>.
 </para>
 <sect1 xml:id="sec.new.bash.start">
  <title>Starten einer Shell</title><indexterm>

  <primary>Shell </primary>

  <secondary>starten</secondary></indexterm>

  <para>
   Grundsätzlich gibt es zwei unterschiedliche Methoden, eine Shell von der
   grafischen Bedienoberfläche zu starten, die gewöhnlich nach dem Start
   Ihres Computers angezeigt wird:
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     Sie können die grafische Bedienoberfläche verlassen oder
    </para>
   </listitem>
   <listitem>
    <para>
     Sie können ein Terminalfenster <emphasis>in </emphasis> der grafischen
     Bedienoberfläche starten.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   Während die erste Option immer verfügbar ist, können Sie die zweite
   Option nur nutzen, wenn Sie bereits bei einem Desktop wie KDE oder GNOME
   angemeldet sind. Für welche Vorgehensweise Sie sich auch entscheiden: Es
   führt immer ein Weg zurück und Sie können zwischen der Shell und der
   grafischen Bedienoberfläche hin und her schalten.
  </para>

  <para>
   Wenn Sie es versuchen möchten, drücken Sie
   <keycombo><keycap function="control"/><keycap function="alt"/><keycap>F2</keycap></keycombo>,
   um die grafische Bedienoberfläche zu verlassen. Die grafische
   Bedienoberfläche wird ausgeblendet und eine Shell fordert Sie auf, sich
   anzumelden. Geben Sie Ihren Benutzernamen ein und drücken Sie
   <keycap function="enter"/>. Geben Sie Ihr Passwort ein und drücken Sie
   <keycap function="enter"/>. Die Eingabeaufforderung zeigt nun einige
   nützliche Informationen wie im folgenden Beispiel an:
  </para>

<screen> <co xml:id="co.prompt.user"/>&nbsp;&nbsp;&nbsp;<co xml:id="co.prompt.hostname"/>&nbsp;&nbsp;&nbsp;<co xml:id="co.prompt.path"/>
tux@linux:~&gt;</screen><indexterm>

  <primary>Shell </primary>

  <secondary>Eingabeaufforderung</secondary></indexterm>

  <calloutlist>
   <callout arearefs="co.prompt.user">
    <para>
     Ihr Benutzername.
    </para>
   </callout>
   <callout arearefs="co.prompt.hostname">
    <para>
     Der Hostname Ihres Computers.
    </para>
   </callout>
   <callout arearefs="co.prompt.path">
    <para>
     Der Pfad zum aktuellen Verzeichnis. Direkt nach der Anmeldung ist das
     aktuelle Verzeichnis in der Regel Ihr Home-Verzeichnis, angezeigt durch
     das Symbol <literal>~</literal> (Tilde).
    </para>
   </callout>
  </calloutlist>

  <para>
   Wenn Sie bei einem entfernten Computer angemeldet sind, zeigen die an der
   Eingabeaufforderung angegebenen Informationen immer an, auf welchem System
   Sie gerade arbeiten.
  </para>

  <para>
   <indexterm>
   <primary>ls</primary>
   </indexterm> Wenn sich der Cursor hinter dieser Eingabeaufforderung
   befindet, können Sie Kommandos direkt an das Computersystem übergeben.
   Beispielsweise können Sie nun <command>ls</command> <option>-l</option>
   eingeben, um den Inhalt des aktuellen Verzeichnisses in einem detaillierten
   Format aufzuführen. Wenn Ihnen dies als erste Begegnung mit der Shell
   genügt und Sie zurück zur grafischen Bedienoberfläche wechseln möchten,
   sollten Sie sich zuerst von der Shell-Sitzung abmelden. Geben Sie hierzu
   <command>exit </command> ein und drücken Sie <keycap function="enter"/>.
   Drücken Sie dann
   <keycombo><keycap function="alt"/><keycap>F7</keycap></keycombo>, um zurück
   zur grafischen Bedienoberfläche zu wechseln. Ihr Desktop und die darauf
   ausgeführten Anwendungen sind unverändert.
  </para>

  <para>
   Wenn Sie bereits beim GNOME- oder KDE-Desktop angemeldet sind und ein
   Terminalfenster auf dem Desktop starten möchten, drücken Sie <keycombo>
   <keycap function="alt"/> <keycap>F2</keycap> </keycombo> und geben Sie
   <command>konsole</command> (für KDE) bzw. <command>gnome-terminal</command>
   (für GNOME) ein. Auf Ihrem Desktop wird ein Terminalfenster geöffnet. Da
   Sie bereits an Ihrem Desktop angemeldet sind, zeigt die Eingabeaufforderung
   die oben beschriebenen Informationen über Ihr System. Sie können nun
   Kommandos eingeben und Aufgaben ausführen wie in jeder beliebigen Shell,
   die parallel zu Ihrem Desktop ausgeführt wird. Um zu einer anderen
   Anwendung auf dem Desktop zu wechseln, klicken Sie einfach in das
   entsprechende Anwendungsfenster oder wählen es aus der Kontrollleiste. Sie
   schließen das Terminalfenster, indem Sie
   <keycombo><keycap function="alt"/><keycap>F4</keycap></keycombo> drücken.
  </para>
 </sect1>
 <sect1 xml:id="sec.new.bash.commands">
  <title>Eingeben von Kommandos</title><indexterm>

  <primary>Bash</primary>

  <secondary>Kommandos</secondary></indexterm>

  <para>
   Sobald die Eingabeaufforderung auf der Shell erscheint, ist sie bereit für
   den Empfang und die Ausführung von Kommandos. Ein Kommando kann aus
   mehreren Elementen bestehen. Das erste Element ist das eigentliche Kommando,
   gefolgt von Parametern oder Optionen. Sie können ein Kommando schreiben und
   anschließend mithilfe der folgenden Tasten bearbeiten:
   <keycap function="left"/>, <keycap function="right"/>,
   <keycap function="home"/>, <keycap function="end"/>,
   <keycap function="backspace"/> (Rücktaste), <keycap function="delete"/> und
   <keycap function="space"/>. Sie können Tippfehler korrigieren oder Optionen
   hinzufügen. Kommandos werden erst ausgeführt, wenn Sie
   <keycap function="enter"/> drücken.
  </para>

  <important>
   <title>Keine Nachricht ist eine gute Nachricht.</title>
   <para>
    Die Shell gibt nicht viele Meldungen aus: Normalerweise erhalten Sie, im
    Unterschied zu einigen grafischen Bedienoberflächen, keine
    Bestätigungsmeldungen, wenn Kommandos ausgeführt wurden. Meldungen werden
    nur bei Problemen oder Fehlern angezeigt, bzw. wenn Sie sie explizit durch
    Ausführen eines Kommandos mit einer bestimmten Option anfordern.
   </para>
   <para>
    Beachten Sie dies auch bei Kommandos zum Löschen von Objekten. Bevor Sie
    ein Kommando zum Entfernen einer Datei eingeben, beispielsweise
    <command>rm</command> (ganz ohne Option), sollten Sie sich sicher sein,
    dass Sie das betreffende Objekt wirklich löschen möchten. Das Objekt wird
    ohne erneute Rückbestätigung unwiederbringlich gelöscht.
   </para>
  </important>

  <sect2 xml:id="sec.new.bash.commands.simple">
   <title>Verwenden von Kommandos ohne Optionen</title>
   <para>
    Eines der grundlegendsten Kommandos ist <command>ls</command>. Hiermit wird
    der Inhalt eines Verzeichnisses aufgelistet. Dieses Kommando kann mit oder
    ohne Optionen verwendet werden. Durch Eingabe des Kommandos
    <command>ls</command> ohne Zusatz wird der Inhalt des aktuellen
    Verzeichnisses angezeigt:
   </para>
<screen>&exampleuser_plain;@&wsIV;:~&gt; ls
bin Desktop Documents public_html tux.txt
tux@knox:~&gt;</screen>
   <para>
    Dateien in Linux können eine Dateiendung oder ein Suffix haben, z. B.
    <literal>.txt</literal>; dies ist aber nicht notwendigerweise der Fall.
    Daher ist es in dieser Ausgabe von <command>ls</command> schwierig, Dateien
    von Ordnern zu unterscheiden. Standardmäßig werden in der Bash-Shell
    jedoch die Verzeichnisse blau und die Dateien schwarz angezeigt.
   </para>
  </sect2>

  <sect2 xml:id="sec.new.bash.commands.options">
   <title>Verwenden von Kommandos mit Optionen</title>
   <para>
    <indexterm>
    <primary>ls </primary>
    <secondary>Optionen </secondary>
    </indexterm>Eine bessere Methode, weitere Details zum Inhalt eines
    Verzeichnisses zu erhalten, besteht darin, das Kommando <command>ls
    </command> mit einer Reihe von Optionen zu verwenden. Durch Optionen wird
    die Funktionsweise eines Kommandos verändert, sodass Sie damit spezielle
    Aufgaben ausführen können. Optionen werden vom Kommando durch ein
    Leerzeichen getrennt und ihnen ist gewöhnlich ein Bindestrich
    vorangestellt. Das Kommando <command>ls</command> <option>-l</option> zeigt
    beispielsweise den Inhalt desselben Verzeichnisses mit allen Details an
    (Long Listing Format).
   </para>
<screen><?dbsuse-fo font-size="0.80em"?>&exampleuser_plain;@&wsIV;:~&gt; ls -l
drwxr-xr-x 1 tux users     48 2016-06-23 16:08 bin
drwx---r-- 1 tux users  53279 2016-06-21 13:16 Desktop
drwx------ 1 tux users    280 2016-06-23 16:08 Documents
drwxr-xr-x 1 tux users  70733 2016-06-21 09:35 public_html
-rw-r--r-- 1 tux users  47896 2016-06-21 09:46 tux.txt
tux@knox:~&gt;</screen>
   <para>
    Diese Ausgabe zeigt die folgenden Informationen über jedes Objekt:
   </para>
<screen><?dbsuse-fo font-size="0.80em"?>drwxr-xr-x<co xml:id="co.ls_l.perm"/> 1<co xml:id="co.ls_l.a"/> tux<co xml:id="co.ls_l.user"/> users<co xml:id="co.ls_l.group"/> 48<co xml:id="co.ls_l.size"/> 2016-06-23 16:08<co xml:id="co.ls_l.date"/> bin<co xml:id="co.ls_l.name"/> </screen>
   <calloutlist>
    <callout arearefs="co.ls_l.perm">
     <para>
      Objekttyp und Zugriffsberechtigungen. Weitere Einzelheiten finden Sie
      unter <xref linkend="sec.new.bash.accperm.ugo"/>.
     </para>
    </callout>
    <callout arearefs="co.ls_l.a">
     <para>
      Anzahl der festen Verknüpfungen zu dieser Datei.
     </para>
    </callout>
    <callout arearefs="co.ls_l.user">
     <para>
      Eigentümer der Datei oder des Verzeichnisses. Weitere Einzelheiten
      finden Sie unter <xref linkend="sec.new.bash.accperm.ugo"/>.
     </para>
    </callout>
    <callout arearefs="co.ls_l.group">
     <para>
      Gruppe, die der Datei oder dem Verzeichnis zugewiesen ist. Weitere
      Einzelheiten finden Sie unter <xref linkend="sec.new.bash.accperm.ugo"/>.
     </para>
    </callout>
    <callout arearefs="co.ls_l.size">
     <para>
      Dateigröße in Byte.
     </para>
    </callout>
    <callout arearefs="co.ls_l.date">
     <para>
      Datum und Uhrzeit der letzten Änderung.
     </para>
    </callout>
    <callout arearefs="co.ls_l.name">
     <para>
      Name des Objekts.
     </para>
    </callout>
   </calloutlist>
   <para>
    Gewöhnlich können Sie mehrere Optionen kombinieren, indem Sie nur der
    ersten Option einen Bindestrich voranstellen und dann die übrigen Optionen
    nacheinander ohne Leerzeichen anfügen. Wenn Sie beispielsweise alle
    Dateien in einem Verzeichnis in einem langen Listenformat sehen möchten,
    können Sie die beiden Optionen <option>-l</option> und <option>-a</option>
    (alle Dateien anzeigen) für das Kommando <command>ls</command>
    kombinieren. Das Kommando <command>ls</command> <option>-la</option> zeigt
    auch verborgene Dateien im Verzeichnis an. Diese werden durch einen
    vorangestellten Punkt gekennzeichnet. (z. B.
    <literal>.verborgenedatei</literal>).
   </para>
   <para>
    Die Liste des Inhalts, die Sie mit <command>ls</command> erhalten, ist
    alphabetisch nach Dateinamen sortiert. Wie in einem grafischen Dateimanager
    können Sie die Ausgabe von <command>ls</command> <option>-l</option> aber
    auch nach verschiedenen Kriterien wie Datum, Dateinamenserweiterung oder
    Dateigröße sortieren:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      Verwenden Sie für Datum und Uhrzeit <command>ls</command>
      <option>-lt</option> (das neueste Element zuerst).
     </para>
    </listitem>
    <listitem>
     <para>
      Verwenden Sie für Erweiterungen <command>ls</command>
      <option>-lx</option> (Dateien ohne Erweiterung zuerst).
     </para>
    </listitem>
    <listitem>
     <para>
      Verwenden Sie für Dateigröße <command>ls</command>
      <option>-lS</option> (die größte Datei zuerst).
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Um die Sortier-Reihenfolge umzukehren, fügen Sie Ihrem Kommando <option>ls
    </option> die Option <command>-r</command> hinzu. Beispielsweise liefert
    <command>ls</command> <option>-lr</option> die Inhaltsliste in umgekehrter
    alphabetischer Reihenfolge, <command>ls</command> <option>-ltr</option>
    zeigt die ältesten Dateien zuerst. Es gibt viele nützliche Optionen für
    <command>ls</command>. Im folgenden Abschnitt erfahren Sie, wie Sie sich
    damit vertraut machen können.
   </para>
  </sect2>

  <sect2 xml:id="sec.new.bash.commands.help">
   <title>Aufrufen der Online-Hilfe</title>
   <para>
    Sie müssen sich nicht alle Optionen für alle Kommandos merken. Wenn Sie
    den Namen eines Kommandos wissen, sich jedoch hinsichtlich der Optionen
    oder der Syntax des Kommandos nicht sicher sind, wählen Sie eine der
    folgenden Möglichkeiten:
   </para>
   <variablelist>
    <varlistentry>
     <term><command/> Option
     </term>
     <listitem>
      <para>
       Wenn Sie nur die Optionen eines bestimmten Kommandos nachsehen möchten,
       geben Sie einfach das Kommando gefolgt von einem Leerzeichen und
       <option>--help</option> ein. Die Option <option>--help</option> ist für
       viele Kommandos verfügbar. Beispielsweise werden durch Eingabe von
       <command>ls</command> <option>--help </option> alle Optionen für das
       Kommando <command>ls </command> angezeigt.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Manualpages</term>
     <listitem>
      <para>
       Für weitere Informationen über die verschiedenen Kommandos können Sie
       auch die Manualpages aufrufen. Manualpages beschreiben kurz, welche
       Funktion das Kommando erfüllt. Sie greifen auf Manualpages mit dem
       Kommando <command>man</command> gefolgt vom Namen des jeweiligen
       Kommandos zu, z. B. <command>man ls</command>.
      </para>
      <para>
       Die Manualpages werden direkt in der Shell angezeigt. Blättern Sie mit
       den Tasten <keycap function="pageup"/> und <keycap function="pagedown"/>
       nach oben bzw. unten. Mit <keycap function="home"/> und
       <keycap function="end"/> gelangen Sie an den Anfang bzw. das Ende eines
       Dokuments. und mit <keycap>Q</keycap> schließen Sie die man-Seiten.
       Weitere Informationen über das Kommando <command>man</command> erhalten
       Sie durch Eingabe von <command>man man</command>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Infoseiten</term>
     <listitem>
      <para>
       Infoseiten bieten gewöhnlich sogar mehr Informationen über Kommandos.
       Die Infoseite für ein bestimmtes Kommando zeigen Sie an, indem Sie
       <command>info</command> gefolgt vom Namen des Kommandos eingeben, z. B.
       <command>info ls</command>). Infoseiten werden direkt in der Shell in
       einem Viewer angezeigt, in dem Sie zwischen den verschiedenen
       Abschnitten, so genannten <quote>Knoten, navigieren können.</quote> Mit
       <keycap function="space"/> blättern Sie vorwärts und mit
       <keycap function="backspace"/> zurück. Innerhalb eines Knotens können
       Sie auch mit <keycap function="pageup"/> und
       <keycap function="pagedown"/> navigieren, jedoch gelangen Sie nur mit
       <keycap function="space"/> und <keycap function="backspace"/> zum
       vorherigen bzw. nächsten Knoten. Drücken Sie wie bei den Manualpages
       <keycap>Q </keycap>, um den Anzeigemodus zu beenden.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Beachten Sie, dass Manualpages und Infoseiten nicht für alle Kommandos
    verfügbar sind. Manchmal sind beide verfügbar (gewöhnlich für
    Schlüsselkommandos), manchmal existiert nur eine man-Seite oder eine
    Infoseite, manchmal nichts von beidem.
   </para>
  </sect2>

  <sect2 xml:id="sec.new.bash.commands.shortcuts">
   <title>Bash-Tastenkombinationen</title><indexterm>
   <primary>Bash </primary>
   <secondary>Tastenkombinationen</secondary></indexterm>
   <para>
    Wenn Sie mehrere Kommandos eingegeben haben, ist Ihre Shell bald mit allen
    Arten von Kommandos und den entsprechenden Ausgaben gefüllt. In der
    folgenden Tabelle finden Sie einige nützliche Tastenkombinationen zum
    Navigieren und Bearbeiten in der Shell.
   </para>
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         Tastenkombination
        </para>
       </entry>
       <entry>
        <para>
         Funktion
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         <keycombo> <keycap function="control"/> <keycap>L</keycap> </keycombo>
        </para>
       </entry>
       <entry>
        <para>
         Löscht den Bildschirm und verschiebt die aktuelle Zeile an den
         Seitenbeginn.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <keycombo> <keycap function="control"/> <keycap>C</keycap> </keycombo>
        </para>
       </entry>
       <entry>
        <para>
         Bricht das Kommando ab, das gerade ausgeführt wird.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <keycombo> <keycap function="shift"/> <keycap function="pageup"/>
         </keycombo>
        </para>
       </entry>
       <entry>
        <para>
         Scrollt nach oben.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <keycombo> <keycap function="shift"/> <keycap function="pagedown"/>
         </keycombo>
        </para>
       </entry>
       <entry>
        <para>
         Scrollt nach unten.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <keycombo> <keycap function="control"/> <keycap>U</keycap> </keycombo>
        </para>
       </entry>
       <entry>
        <para>
         Löscht von Cursorposition bis Zeilenbeginn.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <keycombo> <keycap function="control"/> <keycap>K</keycap> </keycombo>
        </para>
       </entry>
       <entry>
        <para>
         Löscht von Cursorposition bis Zeilenende.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <keycombo> <keycap function="control"/> <keycap>D</keycap> </keycombo>
        </para>
       </entry>
       <entry>
        <para>
         Schließt die Shell-Sitzung.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <keycap function="up"/>, <keycap function="down"/>
        </para>
       </entry>
       <entry>
        <para>
         Durchsucht den Verlauf der ausgeführten Kommandos.
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.new.bash.fildir">
  <title>Arbeiten mit Dateien und Verzeichnissen</title><indexterm>

  <primary>Dateien</primary>

  <secondary>Pfade</secondary></indexterm><indexterm>

  <primary>Verzeichnisse</primary>

  <secondary>Pfade </secondary></indexterm><indexterm>

  <primary>Pfade</primary></indexterm>

  <para>
   Um eine bestimmte Datei bzw. ein bestimmtes Verzeichnis anzusprechen,
   müssen Sie den Pfad angeben, der zu dem betreffenden Verzeichnis bzw. der
   betreffenden Datei führt. Wie Sie vielleicht bereits von MS DOS oder Mac OS
   wissen, gibt es zwei Methoden, einen Pfad anzugeben:
  </para>

  <variablelist>
   <varlistentry>
    <term>Absoluter Pfad <indexterm>
     <primary>Pfade </primary>
     <secondary>absolute</secondary></indexterm>
    </term>
    <listitem>
     <para>
      Geben Sie den vollständigen Pfad vom Root-Verzeichnis zur jeweiligen
      Datei bzw. zum jeweiligen Verzeichnis ein.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Relativer Pfad <indexterm>
     <primary>Pfade </primary>
     <secondary>relative</secondary></indexterm>
    </term>
    <listitem>
     <para>
      Geben Sie einen Pfad zur jeweiligen Datei bzw. zum jeweiligen Verzeichnis
      mit dem aktuellen Verzeichnis als Ausgangspunkt ein. Das bedeutet, dass
      Sie die Ebenen angeben, um die Sie vom aktuellen Verzeichnis ausgehend in
      der Struktur des Dateisystems nach oben oder unten navigieren müssen, um
      das Zielverzeichnis bzw. die Zieldatei zu erreichen.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Pfade enthalten Dateinamen und/oder Verzeichnisse, die durch Schrägstriche
   getrennt sind. Absolute Pfade beginnen immer mit einem Schrägstrich.
   Relativen Pfaden ist kein Schrägstrich vorangestellt, aber sie können
   einen oder zwei Punkte aufweisen.
  </para>

  <para>
   Bei der Eingabe von Kommandos können Sie ganz nach Belieben eine der beiden
   Methoden zur Pfadangabe verwenden, beide führen zum selben Ergebnis. Sie
   wechseln das Verzeichnis mit dem Kommando <command>cd </command> und der
   Pfadangabe zum gewünschten Verzeichnis.
  </para>

  <note>
   <title>Leerzeichen in Datei- oder Verzeichnisnamen</title>
   <para>
    Wenn ein Datei- oder Verzeichnisname ein Leerzeichen enthält, geben Sie
    entweder vor dem Leerzeichen ein Escape-Zeichen (umgekehrter Schrägstrich
    <literal>\\ </literal>) ein oder schließen Sie den Dateinamen in einfache
    Anführungszeichen ein. Andernfalls interpretiert Bash einen Dateinamen wie
    <filename>Eigene Dokumente </filename> als den Namen von zwei Dateien oder
    Verzeichnissen, in diesem Fall <filename>Eigene </filename> und
    <filename>Dokumente </filename>.
   </para>
  </note>

  <para>
   Bei der Angabe von Pfaden können Ihnen die folgenden <quote>Abkürzungen
   </quote> viel Schreibarbeit ersparen:
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     Die Tilde ( <literal>~</literal>) ist eine Abkürzung für
     Home-Verzeichnisse. Um beispielsweise den Inhalt Ihres Home-Verzeichnisses
     aufzulisten, verwenden Sie <command>ls</command> <option>~</option>. Wenn
     Sie den Inhalt des Home-Verzeichnisses von einem anderen Benutzer
     auflisten möchten, geben Sie <command>ls</command> <option>~
     <replaceable>benutzername</replaceable></option> ein. (Natürlich ist dies
     nur möglich, wenn Sie berechtigt sind, den Inhalt anzuzeigen. Siehe
     <xref linkend="sec.new.bash.accperm"/>). Beispielsweise würde <command>ls
     ~tux</command> den Inhalt des Home-Verzeichnisses von Benutzer
     <systemitem class="username">tux</systemitem> auflisten. Sie können die
     Tilde auch als Abkürzung für Home-Verzeichnisse verwenden, wenn Sie in
     einer Netzwerkumgebung arbeiten und Ihr Home-Verzeichnis nicht unbedingt
     <filename>/home</filename> heißt, sondern einem anderen Verzeichnis im
     Dateisystem zugeordnet ist.
    </para>
    <para>
     Sie können von jeder Stelle im Dateisystem zu Ihrem Home-Verzeichnis
     wechseln, indem Sie <command>cd</command> <option>~</option> eingeben oder
     indem Sie einfach <command>cd</command> ohne weitere Optionen eingeben.
    </para>
   </listitem>
   <listitem>
    <para>
     Bei Verwendung von relativen Pfaden geben Sie das aktuelle Verzeichnis mit
     einem Punkt ( <literal>. ) an.</literal>). Dies ist besonders nützlich
     für Kommandos wie <command>cp</command> oder <command>mv</command>, mit
     denen Sie Dateien oder Verzeichnisse kopieren bzw. verschieben können.
    </para>
   </listitem>
   <listitem>
    <para>
     Die nächsthöhere Ebene in der Struktur wird durch zwei Punkte
     dargestellt (<literal>..</literal>). Sie wechseln in das übergeordnete
     Verzeichnis Ihres aktuellen Verzeichnisses, indem Sie <command>cd
     ..</command> eingeben, oder zwei Ebenen über das aktuelle Verzeichnis,
     indem Sie <command>cd ../..</command> eingeben usw.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   Probieren Sie Ihr Wissen in den folgenden Beispielen aus. Sie behandeln
   grundlegende Aufgaben, die Sie mit Bash an Dateien oder Ordnern ausführen
   können.
  </para>

  <sect2 xml:id="sec.new.bash.fildir.ex">
   <title>Beispiele für das Arbeiten mit Dateien und Verzeichnissen</title>
   <para>
    Angenommen, Sie möchten eine Datei aus Ihrem Home-Verzeichnis in ein
    Unterverzeichnis von <filename>/tmp </filename> kopieren, das Sie zuerst
    erstellen müssen:
   </para>
   <procedure>
    <title>Erstellen und Ändern von Verzeichnissen</title>
    <para>
     Erstellen Sie ausgehend von Ihrem Home-Verzeichnis ein Unterverzeichnis in
     <filename>/tmp</filename>:
    </para>
    <step>
     <para>
      Geben Sie ein:
     </para>
<screen>mkdir  /tmp/test</screen>
     <para>
      <command>mkdir</command> steht für <quote>make directory</quote>
      (Verzeichnis anlegen). Mit diesem Kommando erstellen Sie ein neues
      Verzeichnis mit dem Namen <filename>test</filename> im Verzeichnis
      <filename>/tmp. </filename> In diesem Fall verwenden Sie einen absoluten
      Pfad, um das Verzeichnis <filename>test</filename> zu erstellen.
     </para>
    </step>
    <step>
     <para>
      Geben Sie nun das Folgende ein, um zu überprüfen, was geschehen ist:
     </para>
<screen>ls -l /tmp</screen>
     <para>
      Das neue Verzeichnis <filename>test</filename> sollte nun in der
      Inhaltsliste des Verzeichnisses <filename>/tmp</filename> angezeigt
      werden.
     </para>
    </step>
    <step>
     <para>
      Wechseln Sie in das neu erstellte Verzeichnis mit
     </para>
<screen>cd /tmp/test</screen>
    </step>
   </procedure>
   <procedure>
    <title>Erstellen und Kopieren von Dateien</title>
    <para>
     Erstellen Sie nun eine neue Datei in Ihrem Home-Verzeichnis und kopieren
     Sie sie in das Verzeichnis <filename>/tmp/test</filename>. Verwenden Sie
     für diese Aufgabe einen relativen Pfad.
    </para>
    <important>
     <title>Überschreiben von bestehenden Dateien</title>
     <para>
      Bevor Sie eine Datei kopieren, verschieben oder umbenennen, prüfen Sie,
      ob Ihr Zielverzeichnis bereits eine Datei mit demselben Namen enthält.
      Wenn ja, ändern Sie ggf. einen der Dateinamen oder verwenden Sie
      <command>cp</command> bzw. <command>mv</command> mit Optionen wie
      <option>-i</option>, die Sie zu einer Eingabe auffordert, bevor eine
      bestehende Datei überschrieben wird. Andernfalls überschreibt Bash die
      vorhandene Datei ohne Bestätigung.
     </para>
    </important>
    <step>
     <para>
      Geben Sie zum Auflisten des Inhalts Ihres Home-Verzeichnisses Folgendes
      ein:
     </para>
<screen>ls -l ~</screen>
     <para>
      Es sollte standardmäßig ein Unterverzeichnis mit dem Namen
      <filename>Dokumente</filename> enthalten. Wenn nicht, erstellen Sie
      dieses Unterverzeichnis mit dem Kommando <command>mkdir</command>, das
      Sie bereits kennen:
     </para>
<screen>mkdir ~/Documents</screen>
    </step>
    <step>
     <para>
      Geben Sie zur Erstellung einer neuen, leeren Datei mit dem Namen
      <filename>myfile.txt</filename> im Verzeichnis
      <filename>Dokumente</filename> Folgendes ein:
     </para>
<screen>touch ~/Documents/myfile.txt</screen>
     <para>
      Gewöhnlich aktualisiert das Kommando <command>touch</command> das
      Änderungs- und Zugriffsdatum für eine bestehende Datei. Wenn Sie
      <command>touch</command> mit einem Dateinamen verwenden, der im
      Zielverzeichnis nicht existiert, wird eine entsprechende neue Datei
      angelegt.
     </para>
    </step>
    <step>
     <para>
      Geben Sie ein:
     </para>
<screen>ls -l ~/Documents</screen>
     <para>
      Die neue Datei sollte in der Inhaltsliste angezeigt werden.
     </para>
    </step>
    <step>
     <para>
      Geben Sie zum Kopieren der neu erstellten Datei Folgendes ein:
     </para>
<screen>cp ~/Documents/myfile.txt .</screen>
     <para>
      Vergessen Sie nicht den Punkt am Ende.
     </para>
     <para>
      Dieses Kommando weist Bash an, direkt in Ihr Home-Verzeichnis zu wechseln
      und <filename>myfile.txt</filename> aus dem Unterverzeichnis
      <filename>Dokumente</filename> in das aktuelle Verzeichnis
      <filename>/tmp/test</filename> zu kopieren, ohne den Namen der Datei zu
      ändern.
     </para>
    </step>
    <step>
     <para>
      Prüfen Sie das Ergebnis, indem Sie Folgendes eingeben:
     </para>
<screen>ls -l</screen>
     <para>
      Die Datei <filename>myfile.txt</filename> sollte nun in der Inhaltsliste
      für <filename>/tmp/test</filename> angezeigt werden.
     </para>
    </step>
   </procedure>
   <procedure>
    <title>Umbenennen und Entfernen von Dateien oder Verzeichnissen</title>
    <para>
     Angenommen, Sie möchten nun <filename>myfile.txt</filename> in
     <filename>tuxfile.txt</filename> umbenennen. Zum Schluss beschließen Sie,
     die umbenannte Datei und das Unterverzeichnis <filename>test</filename> zu
     entfernen.
    </para>
    <step>
     <para>
      Geben Sie zum Umbenennen der Datei das folgende Kommando ein:
     </para>
<screen>mv myfile.txt tuxfile.txt</screen>
    </step>
    <step>
     <para>
      Geben Sie das Folgende ein, um zu überprüfen, was geschehen ist:
     </para>
<screen>ls -l</screen>
     <para>
      Anstelle von <filename>myfile.txt</filename> sollte nun
      <filename>tuxfile.txt</filename> in der Inhaltsliste angezeigt werden.
     </para>
     <para>
      <command>mv</command> steht für <literal>move</literal> (verschieben)
      und wird mit zwei Optionen verwendet: Mit der ersten Option wird die
      Quelle des Vorgangs, mit der zweiten Option das Ziel angegeben. Sie
      können <command>mv</command> für Folgendes verwenden:
     </para>
     <itemizedlist mark="bullet" spacing="normal">
      <listitem>
       <para>
        Umbenennen einer Datei oder eines Verzeichnisses,
       </para>
      </listitem>
      <listitem>
       <para>
        Verschieben einer Datei oder eines Verzeichnisses an eine andere
        Position oder
       </para>
      </listitem>
      <listitem>
       <para>
        Ausführen beider Aktionen in einem Schritt.
       </para>
      </listitem>
     </itemizedlist>
    </step>
    <step>
     <para>
      Sie entscheiden, dass Sie die Datei nicht mehr brauchen, und löschen
      sie, indem Sie Folgendes eingeben:
     </para>
<screen>rm tuxfile.txt </screen>
     <para>
      Bash löscht die Datei ohne Bestätigung.
     </para>
    </step>
    <step>
     <para>
      Wechseln Sie mit <command>cd ..</command> um eine Ebene nach oben und
      prüfen Sie mit
     </para>
<screen>ls -l test</screen>
     <para>
      ob das Verzeichnis <filename>test</filename> nun leer ist.
     </para>
    </step>
    <step>
     <para>
      Wenn ja, können Sie das Verzeichnis <filename>test</filename> entfernen,
      indem Sie folgendes eingeben:
     </para>
<screen>rmdir test</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.new.bash.root">
  <title>Umschalten zu Root</title><indexterm>

  <primary>Shell </primary>

  <secondary>root</secondary></indexterm>

  <para>
   Der rootuser;, auch als Systemadministrator bezeichnet, verfügt über Privilegien,
   die ihn zum Zugriff auf alle Bereiche des Systems und zur Ausführung von
   administrativen Aufgaben berechtigen. Er kann uneingeschränkt Änderungen
   am System vornehmen und unbegrenzt auf alle Dateien zugreifen. Das
   Ausführen von einigen administrativen Aufgaben oder bestimmten Programmen
   wie &yast; erfordert daher &rootuser;-Berechtigungen.
  </para>

  <sect2 xml:id="sec.new.bash.root.su">
   <title>Verwenden von <command>su</command></title>
   <para>
    Gehen Sie wie folgt vor, um in einer Shell temporär als &rootuser; zu
    arbeiten:
   </para>
   <procedure>
    <step>
     <para>
      Geben Sie <command>su</command> ein. Sie werden zur Eingabe des
      &rootuser;-Passworts aufgefordert.
     </para>
    </step>
    <step>
     <para>
      Passwort eingeben. Wenn Sie das &rootuser;-Passwort falsch geschrieben
      haben, zeigt die Shell eine Meldung an. Wiederholen Sie in diesem Fall
      die Eingabe von <command>su</command>, bevor Sie das Passwort erneut
      eingeben. Wenn Ihr Passwort korrekt ist, zeigt ein Nummernzeichen
      <literal>&num;</literal> am Ende der Eingabeaufforderung, dass Sie nun
      als &rootuser; agieren.
     </para>
    </step>
    <step>
     <para>
      Führen Sie Ihre Aufgabe aus. Sie können beispielsweise die
      Eigentümerschaft einer Datei an einen neuen Benutzer übertragen; hierzu
      ist nur &rootuser; berechtigt.
     </para>
<screen>chown &exampleuserII_plain; kde_quick.xml</screen>
    </step>
    <step>
     <para>
      Sobald alle Ihre Aufgaben als &rootuser; erledigt sind, wechseln Sie
      wieder in Ihr normales Benutzerkonto. Geben Sie dazu Folgendes ein:
     </para>
<screen>exit</screen>
     <para>
      Das Nummernzeichen verschwindet und Sie agieren wieder als
      <quote>normaler</quote> Benutzer.
     </para>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec.new.bash.root.sudo">
   <title>Verwenden von <command>sudo</command></title>
   <para>
    Sie können auch <command>sudo</command> (superuser <quote>do</quote>)
    verwenden, um einige Aufgaben durchzuführen, die normalerweise
    &rootuser;n vorbehalten sind. Mit sudo können Administratoren
    bestimmten Benutzern &rootuser;-Privilegien für einige Kommandos
    erteilen. Je nach Systemkonfiguration können Benutzer dann
    &rootuser;-Kommandos ausführen und müssen hierfür nur ihr normales
    Passwort eingeben. Aufgrund einer Zeitstempelfunktion wird Benutzern nur
    ein <quote>Ticket</quote> für eine beschränkte Zeitspanne nach Eingabe
    des Passworts gewährt. Das Ticket läuft in der Regel nach wenigen Minuten
    ab. In &opensuse; ist für sudo standardmäßig das
    &rootuser;-Passwort erforderlich (falls vom Systemadministrator nicht
    anderweitig konfiguriert).
   </para>
   <para>
    Für Benutzer ist sudo praktisch, da Sie davon abgehalten werden, zweimal
    zwischen den Konten zu wechseln (zu &rootuser; und wieder zurück). Zum
    Ändern der Eigentümerschaft einer Datei ist bei Verwendung von sudo statt
    der Eingabe von drei Kommandos nur ein Kommando erforderlich:
   </para>
<screen>sudo chown &exampleuserII_plain; kde_quick.xml</screen>
   <para>
    Nachdem Sie das angeforderte Passwort eingegeben haben, wird das Kommando
    ausgeführt. Wenn Sie kurz darauf ein zweites &rootuser;-Kommando
    eingeben, werden Sie nicht erneut zur Eingabe des Passworts aufgefordert,
    da das Ticket noch gültig ist. Nach einer bestimmten Zeitspanne läuft das
    Ticket automatisch ab und das Passwort muss wieder eingegeben werden.
    Hierdurch wird außerdem verhindert, dass unbefugten Personen
    &amp;rootuser-Privilegien erteilt werden, falls ein Benutzer vergisst,
    wieder zu seinem normalen Benutzerkonto zu wechseln und eine
    &rootuser;-Shell offen lässt.
   </para>
  </sect2>
 </sect1>
 <xi:include href="newbie_perm_i.xml" parse="xml"/>
 <sect1 xml:id="sec.new.bash.feat">
  <title>Nützliche Funktionen der Shell</title><indexterm>

  <primary>Bash</primary>

  <secondary>Funktionen</secondary></indexterm>

  <para>
   Wie Sie wahrscheinlich in den obigen Beispielen bemerkt haben, kann die
   Kommandoeingabe in Bash viel Schreibarbeit erfordern. Im Folgenden lernen
   Sie einige Funktionen von Bash kennen, die Ihre Arbeit erleichtern und Ihnen
   viel Tippaufwand ersparen können.
  </para>

  <variablelist>
   <varlistentry>
    <term>History <indexterm>
     <primary>Bash </primary>
     <secondary>History</secondary></indexterm><indexterm>
     <primary>History</primary>
     <secondary>Bash</secondary></indexterm>
    </term>
    <listitem>
     <para>
      Standardmäßig <quote>merkt</quote> sich Bash die Kommandos, die Sie
      eingeben. Diese Funktion wird <emphasis>History</emphasis> genannt. Sie
      können durch die Kommandos navigieren, die zuvor eingegeben wurden, das
      gewünschte Kommando zur Wiederholung auswählen und dann erneut
      ausführen. Drücken Sie dazu wiederholt die Taste
      <keycap function="up"/>, bis das gewünschte Kommando an der
      Eingabeaufforderung angezeigt wird. Drücken Sie
      <keycap function="down"/>, um sich vorwärts durch die Liste der zuvor
      eingegebenen Kommandos zu bewegen. Für die mühelose wiederholte
      Ausführung eines bestimmten Kommandos aus der Bash-History, geben Sie
      einfach den ersten Buchstaben des zu wiederholenden Kommandos ein und
      drücken Sie <keycap function="pageup"/>.
     </para>
     <para>
      Sie können nun das ausgewählte Kommando ändern (indem Sie
      beispielsweise den Namen einer Datei oder einen Pfad ändern), bevor Sie
      das Kommando durch Drücken von <keycap function="enter"/> ausführen. Um
      die Kommandozeile zu bearbeiten, verschieben Sie den Cursor mit den
      Pfeiltasten an die gewünschte Position und beginnen die Eingabe.
     </para>
     <para>
      Sie können auch ein bestimmtes Kommando in der History suchen. Drücken
      Sie <keycombo><keycap function="control"/> <keycap>R</keycap></keycombo>
      , um eine inkrementelle Suchfunktion zu starten. Diese zeigt die folgende
      Eingabeaufforderung:
     </para>
<screen> (reverse-i-search)`': </screen>
     <para>
      Geben Sie einfach einen oder mehrere Buchstaben des gesuchten Kommandos
      ein. Jedes eingegebene Zeichen engt die Suche ein. Das entsprechende
      Suchergebnis wird rechts neben dem Doppelpunkt und Ihre Eingabe links
      neben dem Doppelpunkt gezeigt. Um ein Suchergebnis zu akzeptieren,
      drücken Sie <keycap function="escape"/>. Die Eingabeaufforderung
      übernimmt ihr normales Aussehen und zeigt das gewählte Kommando an. Sie
      können das Kommando nun bearbeiten oder direkt ausführen, indem Sie
      <keycap function="enter"/> drücken.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Ergänzung</term>
    <listitem>
     <para>
      Die Ergänzung eines Datei- oder Verzeichnisnamens nach der Eingabe der
      ersten Buchstaben ist eine weitere hilfreiche Funktion von Bash. Geben
      Sie hierzu die ersten Buchstaben einer vorhandenen Datei oder eines
      vorhandenen Verzeichnisses ein und drücken Sie <keycap function="tab"/>
      (Tabulator). Wenn der Dateiname bzw. Pfad eindeutig identifiziert werden
      kann, wird er sofort ergänzt und der Cursor springt zum Ende des
      Dateinamens. Anschließend können Sie die nächste Option des Kommandos
      eingeben, falls erforderlich. Wenn der Dateiname oder Pfad nicht
      eindeutig identifiziert werden kann (da mehrere Dateinamen mit denselben
      Buchstaben beginnen), wird der Dateiname oder Pfad nur so weit ergänzt,
      bis mehrere Varianten möglich sind. Eine Auflistung dieser Varianten
      erhalten Sie, indem Sie ein zweites Mal die Taste
      <keycap function="tab"/> drücken. Anschließend können Sie die
      nächsten Buchstaben der Datei bzw. des Pfads eingeben und erneut die
      Ergänzungsfunktion durch Drücken von <keycap function="tab"/>
      aktivieren. Wenn Sie Dateinamen und Pfaden mithilfe von
      <keycap function="tab"/> ergänzen, können Sie gleichzeitig
      überprüfen, ob die Datei bzw. der Pfad, den Sie eingeben möchten,
      tatsächlich vorhanden ist (und Sie können sicher sein, dass er richtig
      geschrieben ist).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Platzhalter <indexterm>
     <primary>Bash</primary>
     <secondary>Platzhalter</secondary></indexterm><indexterm>
     <primary>Platzhalter</primary>
     <secondary>Bash</secondary></indexterm>
    </term>
    <listitem>
     <para>
      Sie können ein oder mehrere Zeichen in einem Dateinamen durch einen
      Platzhalter zur Pfadnamenerweiterung ersetzen. Platzhalter sind Zeichen,
      die für andere Zeichen stehen. Bash kennt drei verschiedene Arten von
      Platzhaltern:
     </para>
     <informaltable>
      <tgroup cols="2">
       <tbody>
        <row>
         <entry>
          <para>
           Platzhalter
          </para>
         </entry>
         <entry>
          <para>
           Funktion
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
           <literal>?</literal>
          </para>
         </entry>
         <entry>
          <para>
           Stimmt genau mit einem zufälligen Zeichen überein
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
           <literal>&ast;</literal>
          </para>
         </entry>
         <entry>
          <para>
           Stimmt mit einer beliebigen Zahl an Zeichen überein
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
           <literal>&lsqb;<replaceable>set</replaceable>&rsqb;</literal>
          </para>
         </entry>
         <entry>
          <para>
           Stimmt mit einem Zeichen aus der Gruppe überein, die in den eckigen
           Klammern angegeben wurde und hier durch die Zeichenfolge
           <replaceable>set</replaceable> dargestellt wird.
          </para>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </listitem>
   </varlistentry>
  </variablelist>

  <sect2 xml:id="sec.new.bash.feat.ex">
   <title>Beispiele für die Verwendung von History, Ergänzung und Platzhaltern</title>
   <para>
    Die folgenden Beispiele illustrieren, wie Sie diese praktischen Funktionen
    von Bash nutzen können.
   </para>
   <procedure>
    <title>Verwenden von Verlauf und Vervollständigung</title>
    <para>
     Wie bereits im Beispiel <xref linkend="sec.new.bash.fildir.ex"/> sollte
     Ihr Shell-Puffer mit Kommandos gefüllt sein, die Sie mithilfe der
     History-Funktion abrufen können.
    </para>
    <step>
     <para>
      Drücken Sie wiederholt <keycap function="up"/>, bis <command>cd
      ~</command> angezeigt wird.
     </para>
    </step>
    <step>
     <para>
      Drücken Sie <keycap function="enter"/>, um das Kommando auszuführen und
      in Ihr Home-Verzeichnis zu wechseln.
     </para>
     <para>
      Standardmäßig enthält Ihr Home-Verzeichnis zwei Unterverzeichnisse,
      die mit demselben Buchstaben beginnen: <filename>Dokumente</filename> und
      <filename>Desktop</filename>.
     </para>
    </step>
    <step>
     <para>
      Geben Sie <command>cd D</command> ein und drücken Sie
      <keycap function="tab"/>.
     </para>
     <para>
      Nichts geschieht, da Bash nicht feststellen kann, in welches der
      Unterverzeichnisse Sie wechseln möchten.
     </para>
    </step>
    <step>
     <para>
      Drücken Sie erneut <keycap function="tab"/>, um die Liste möglicher
      Optionen zu sehen:
     </para>
<screen>&exampleuser_plain;@&wsIV;:~&gt; cd D
Desktop/   Documents/ Downloads/
&exampleuser_plain;@&wsIV;:~&gt; cd D</screen>
    </step>
    <step>
     <para>
      Die Eingabeaufforderung zeigt immer noch Ihre ursprüngliche Eingabe.
      Geben Sie den nächsten Buchstaben des Unterverzeichnisses ein, in das
      Sie wechseln möchten, und drücken Sie erneut <keycap function="tab"/>.
     </para>
     <para>
      Bash vervollständigt nun den Pfad.
     </para>
    </step>
    <step>
     <para>
      Sie können nun das Kommando mit <keycap function="enter"/> ausführen.
     </para>
    </step>
   </procedure>
   <procedure>
    <title>Verwenden von Platzhalterzeichen</title>
    <para>
     Angenommen, Ihr Home-Verzeichnis enthält eine Reihe von Dateien mit
     verschiedenen Dateinamenserweiterungen. Es enthält auch mehrere Versionen
     einer Datei, die Sie unter verschiedenen Dateinamen gespeichert haben (
     <filename>myfile1.txt </filename>, <filename>myfile2.txt </filename>
     usw.). Sie möchten bestimmte Dateien gemäß ihren Eigenschaften suchen.
    </para>
    <step>
     <para>
      Erstellen Sie zunächst einige Testdateien in Ihrem Home-Verzeichnis:
     </para>
     <substeps performance="required">
      <step>
       <para>
        Verwenden Sie das Kommando <command>touch</command>, um mehrere (leere)
        Dateien mit verschiedenen Dateierweiterungen zu erstellen, z. B.
        <filename>.pdf</filename>, <filename>.xml</filename> und
        <filename>.jpg</filename>.
       </para>
       <para>
        Sie können diesen Vorgang wiederholt (denken Sie an die
        Bash-Verlauf-Funktion) oder nur mit einem einzigen
        <command>touch</command>-Kommando durchführen: Fügen Sie einfach
        mehrere Dateinamen hinzu, die jeweils durch ein Leerzeichen voneinander
        getrennt sind.
       </para>
      </step>
      <step>
       <para>
        Erstellen Sie mindestens zwei Dateien mit derselben
        Dateinamenserweiterung, z. B. <filename>.html</filename>.
       </para>
      </step>
      <step>
       <para>
        Geben Sie zum Erstellen mehrerer <quote>Versionen </quote> einer Datei
        das Folgende ein:
       </para>
<screen>touch myfile{1..5}.txt</screen>
       <para>
        Dieses Kommando erstellt fünf fortlaufend nummerierte Dateien:
       </para>
<screen>myfile1.txt,&hellip;,myfile5.txt</screen>
      </step>
      <step>
       <para>
        Zeigen Sie den Inhalt Ihres Home-Verzeichnisses an. Er sollte etwa wie
        folgt aussehen:
       </para>
<screen><?dbsuse-fo font-size="0.70em"?>-rw-r--r-- 1 tux users   0 2016-07-14 13:34 foo.xml
-rw-r--r-- 1 tux users   0 2016-07-14 13:47 home.html
-rw-r--r-- 1 tux users   0 2016-07-14 13:47 index.html
-rw-r--r-- 1 tux users   0 2016-07-14 13:47 toc.html
-rw-r--r-- 1 tux users   0 2016-07-14 13:34 manual.pdf
-rw-r--r-- 1 tux users   0 2016-07-14 13:49 myfile1.txt
-rw-r--r-- 1 tux users   0 2016-07-14 13:49 myfile2.txt
-rw-r--r-- 1 tux users   0 2016-07-14 13:49 myfile3.txt
-rw-r--r-- 1 tux users   0 2016-07-14 13:49 myfile4.txt
-rw-r--r-- 1 tux users   0 2016-07-14 13:49 myfile5.txt
-rw-r--r-- 1 tux users   0 2016-07-14 13:32 tux.png
       </screen>
      </step>
     </substeps>
    </step>
    <step>
     <para>
      Wählen Sie mithilfe von Platzhaltern bestimmte Untergruppen von Dateien
      nach verschiedenen Kriterien aus:
     </para>
     <substeps performance="required">
      <step>
       <para>
        Um alle Dateien mit der Erweiterung <filename>.html </filename>
        aufzulisten, geben Sie Folgendes ein:
       </para>
<screen> ls -l *.html</screen>
      </step>
      <step>
       <para>
        Um alle <quote>Versionen</quote> von <filename>myfile.txt</filename>
        aufzulisten, geben Sie Folgendes ein
       </para>
<screen>ls -l myfile?.txt</screen>
       <para>
        Beachten Sie, dass Sie hier nur das Jokerzeichen <literal>? </literal>
        verwenden können, da die Nummerierung der Dateien einstellig ist. Wenn
        Sie eine Datei mit dem Namen <filename>myfile10.txt</filename> haben,
        müssen Sie den Platzhalter <literal>&ast;</literal> verwenden, um
        alle Versionen von <filename>myfile.txt</filename> zu sehen (oder ein
        weiteres Fragezeichen hinzufügen, sodass Ihre Zeichenfolge wie
        <command>myfile??.txt</command> aussieht).
       </para>
      </step>
      <step>
       <para>
        Um beispielsweise die Versionen 1 bis 3 und Version 5 von
        <filename>myfile.txt </filename> zu entfernen, geben Sie Folgendes ein:
       </para>
<screen>rm myfile[1-3,5].txt</screen>
      </step>
      <step>
       <para>
        Prüfen Sie das Ergebnis mit
       </para>
<screen>ls -l</screen>
       <para>
        Von allen <filename>myfile.txt </filename>-Versionen sollte nur
        <filename>myfile4.txt </filename> übrig sein.
       </para>
      </step>
     </substeps>
    </step>
   </procedure>
   <para>
    Sie können auch mehrere Platzhalter in einem Kommando kombinieren. Im
    obigen Beispiel würde <command>rm myfile&lsqb;1-3,5&rsqb;.&ast;
    </command> dasselbe Ergebnis liefern wie <command>rm
    myfile&lsqb;1-3,5&rsqb;.txt </command>, da nur Dateien mit der
    Erweiterung <filename>.txt </filename> vorhanden sind.
   </para>
   <note>
    <title>Verwenden von Platzhaltern in Kommandos</title>
    <para>
     Platzhalter in einem <command>rm</command>-Kommando können ausgesprochen
     nützlich sein, bergen jedoch auch ein gewisses Risiko, da unter
     Umständen mehr Dateien aus dem Verzeichnis gelöscht werden, als
     beabsichtigt war. Sie sehen, welche Dateien durch <command>rm </command>
     betroffen sind, indem Sie Ihre Platzhalterzeichenfolge zuerst mit
     <command>ls </command> anstelle von <command>rm</command> ausführen.
    </para>
   </note>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.new.bash.edit">
  <title>Bearbeiten von Texten</title><indexterm>

  <primary>Dateien</primary>

  <secondary>bearbeiten</secondary></indexterm><indexterm>

  <primary>vi</primary></indexterm><indexterm>

  <primary>Editor</primary>

  <secondary>vi</secondary></indexterm>

  <para>
   Zum Bearbeiten von Dateien von der Kommandozeile aus lernen Sie früher oder
   später den vi-Editor kennen. vi ist ein Standard-Editor, der auf nahezu
   jedem UNIX/Linux-System zur Verfügung steht. Er kann mehrere Betriebsmodi
   ausführen, in denen die gedrückten Tasten unterschiedliche Funktionen
   haben. Das ist nicht besonders einfach für Anfänger, aber Sie sollten
   zumindest die grundlegendsten Operationen mit vi kennen. Es kann Situationen
   geben, in denen außer vi kein anderer Editor verfügbar ist.
  </para>

  <para>
   In vi werden drei grundlegende Betriebsmodi verwendet:
  </para>

  <variablelist>
   <varlistentry>
    <term><emphasis>Kommando </emphasis>-Modus</term>
    <listitem>
     <para>
      In diesem Modus akzeptiert vi bestimmte Tastenkombinationen als
      Kommandos. Einfache Aufgaben wie das Suchen nach Wörtern oder das
      Löschen einer Zeile können ausgeführt werden.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><emphasis>Einfüge </emphasis>-Modus</term>
    <listitem>
     <para>
      In diesem Modus können Sie normalen Text schreiben.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><emphasis>Erweiterter </emphasis> Modus</term>
    <listitem>
     <para>
      In diesem Modus, der auch Doppelpunktmodus genannt wird (weil zum
      Wechseln in diesen Modus ein Doppelpunkt eingegeben werden muss), kann vi
      auch komplexere Aufgaben wie Suchen und Ersetzen von Text ausführen.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Im folgenden (sehr einfachen) Beispiel lernen Sie, wie Sie eine Datei mit vi
   öffnen und bearbeiten, Ihre Änderungen speichern und vi beenden können.
  </para>

  <sect2 xml:id="sec.new.bash.edit.ex">
   <title>Beispiel: Bearbeitung mit vi</title>
   <procedure>
    <note>
     <title>Anzeige der Tasten</title>
     <para>
      Im Folgenden finden Sie mehrere Kommandos, die Sie in vi einfach durch
      das Drücken von Tasten eingeben können. Diese werden in Großbuchstaben
      angezeigt, wie auf einer Tastatur. Wenn Sie einen Buchstaben als
      Großbuchstaben eingeben müssen, wird dies explizit angegeben: Es wird
      eine Tastenkombination mit der Taste <keycap function="shift"/>
      angezeigt.
     </para>
    </note>
    <step>
     <para>
      Geben Sie zum Erstellen und Öffnen einer neuen Datei mit vi das Folgende
      ein:
     </para>
<screen>vi textfile.txt</screen>
     <para>
      Standardmäßig wird vi im <emphasis>Kommando </emphasis>-Modus
      geöffnet, in dem Sie keinen Text eingeben können.
     </para>
    </step>
    <step>
     <para>
      Drücken Sie <keycap>I </keycap>, um in den Einfüge-Modus zu wechseln.
      Die untere Zeile ändert sich, um anzuzeigen, dass Sie nun Text einfügen
      können.
     </para>
    </step>
    <step>
     <para>
      Schreiben Sie ein paar Sätze. Wenn Sie eine neue Zeile einfügen
      möchten, drücken Sie zunächst <keycap function="escape"/>, um in den
      Kommandomodus umzuschalten. Drücken Sie <keycap>O </keycap>, um eine
      neue Zeile einzufügen und wieder in den Einfüge-Modus zu wechseln.
     </para>
    </step>
    <step>
     <para>
      Im Einfüge-Modus können Sie den Text mit den Pfeiltasten und mit
      <keycap function="delete"/> bearbeiten.
     </para>
    </step>
    <step>
     <para>
      Wenn Sie vi beenden möchten, drücken Sie <keycap function="escape"/>,
      um wieder in den Kommandomodus zu wechseln. Drücken Sie dann
      <keycap>:</keycap>, um in den erweiterten Modus zu gelangen. Die untere
      Zeile zeigt nun einen Doppelpunkt.
     </para>
    </step>
    <step>
     <para>
      Um vi zu beenden und Ihre Änderungen zu speichern, geben Sie
      <command>wq</command> ( <literal>w</literal> für
      <literal>write</literal> (schreiben); <literal>q</literal> für
      <literal>quit</literal> (Beenden)) ein und drücken
      Sie<keycap function="enter"/> . Wenn Sie die Datei unter einem anderen
      Namen speichern möchten, geben Sie <command>w</command>
      <replaceable>Dateiname </replaceable> ein und drücken Sie
      <keycap function="enter"/>.
     </para>
     <para>
      Um vi ohne Speichern zu beenden, geben Sie stattdessen
      <command>q!</command> ein und drücken Sie <keycap function="enter"/>.
     </para>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.new.bash.search">
  <title>Suchen nach Dateien oder Inhalten</title>

  <para>
   Bash bietet Ihnen mehrere Kommandos zur Suche nach Dateien und dem Inhalt
   von Dateien:
  </para>

  <variablelist>
   <varlistentry>
    <term><command>locate</command>
    </term>
    <listitem>
     <para>
      Dieses Dienstprogramm steht nur zur Verfügung, wenn das Paket
      <systemitem class="resource">findutils-locate</systemitem> installiert
      ist. Mit diesem Kommando finden Sie den Speicherort der angegebenen
      Datei. Zur Angabe von Dateinamen können Sie auch Platzhalter verwenden.
      Das Programm ist sehr schnell, da es die Dateien in einer speziell für
      diesen Zweck erstellten Datenbank sucht, also nicht das gesamte
      Dateisystem durchsuchen muss. Hierdurch ergibt sich auch ein wesentlicher
      Nachteil: locate kann keine Dateien finden, die nach der letzten
      Aktualisierung der Datenbank erstellt wurden. Die Datenbank wird mit
      <systemitem class="username">updatedb</systemitem> aktualisiert. Dazu
      benötigen Sie allerdings <command>Root</command>-Berechtigungen.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>find</command><indexterm>
     <primary>Kommandos</primary>
     <secondary>find</secondary></indexterm>
    </term>
    <listitem>
     <para>
      Mit diesem Kommando <command>können Sie ein bestimmtes Verzeichnis nach
      einer Datei durchsuchen. </command> Das erste Argument gibt das
      Verzeichnis an, in dem die Suche beginnt. Nach der Option
      <option>-name</option> muss der gesuchte Dateiname eingegeben werden
      (eventuell auch mit Platzhaltern). Im Gegensatz zu
      <command>locate</command>, das eine Datenbank durchsucht, sucht
      <command>find</command> nur im angegebenen Verzeichnis.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>grep</command><indexterm>
     <primary>Kommando</primary>
     <secondary>grep</secondary></indexterm>
    </term>
    <listitem>
     <para>
      Mit dem Kommando <command>grep </command> können Sie die angegebenen
      Dateien nach einer bestimmten Suchzeichenfolge durchsuchen. Wird das
      gesuchte Wort gefunden, dann wird die Zeile, in der sich die
      <literal>Suchzeichenfolge</literal> befindet, mit dem Namen der
      betreffenden Datei angezeigt. Zur Angabe von Dateinamen können Sie auch
      Platzhalter verwenden.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <sect2>
   <title>Beispiele für Suchen</title>
   <procedure>
    <para>
     Die KDE- und GNOME-Desktops speichern benutzerspezifische Anwendungsdaten
     in verborgenen Verzeichnissen, z. B. <filename>.kde</filename> und
     <filename>.gnome</filename>.
    </para>
    <step>
     <para>
      Sie finden diese Verzeichnisse auf Ihrem Computer, indem Sie das Folgende
      eingeben:
     </para>
<screen>locate .kde</screen>
     <para>
      wenn KDE-Desktop installiert ist, oder:
     </para>
<screen>locate .gnome</screen>
     <para>
      wenn GNOME-Desktop installiert ist.
     </para>
     <para>
      Sie werden sehen, dass <command>locate </command> alle Dateinamen in der
      Datenbank anzeigt, die an beliebiger Stelle die Zeichenfolge
      <literal>.kde </literal> bzw. <literal>.gnome </literal> enthalten. Wie
      Sie dieses Verhalten ändern können, erfahren Sie auf der Manualpage
      für <command>locate</command>.
     </para>
    </step>
    <step>
     <para>
      Zum Durchsuchen Ihres Home-Verzeichnisses nach allen Instanzen von
      Dateien mit der Dateinamenserweiterung <filename>.txt </filename> geben
      Sie das Folgende ein:
     </para>
<screen>find ~ -name '*.txt' -print</screen>
    </step>
    <step>
     <para>
      Zum Durchsuchen eines Verzeichnisses (in diesem Fall das
      Home-Verzeichnis) nach allen Instanzen von Dateien, die beispielsweise
      das Wort <literal>music </literal> enthalten, geben Sie das Folgende ein:
     </para>
<screen>grep music ~/*</screen>
     <para>
      Beachten Sie, dass bei grep die Groß- und Kleinschreibung unterschieden
      wird, sofern die Verwendung nicht mit der Option <option>-i</option>
      erfolgt. Mit dem obigen Kommando finden Sie keine Dateien, die das Wort
      <literal>Music </literal> enthalten.
     </para>
     <para>
      Wenn Sie eine Suchzeichenfolge verwenden, die aus mehreren Wörtern
      besteht, umgeben Sie die Zeichenfolge mit doppelten Anführungszeichen,
      z. B.:
     </para>
<screen>grep "music is great" ~/*</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.new.bash.view">
  <title>Anzeigen von Textdateien</title><indexterm>

  <primary>Dateien</primary>

  <secondary>anzeigen</secondary></indexterm>

  <para>
   Wenn Sie den Inhalt einer Datei mit <command>grep </command> suchen, liefert
   das Ergebnis die Zeile, in der sich der <literal>searchstring </literal>
   (die Suchzeichenfolge) befindet, sowie den Dateinamen. Häufig genügt diese
   Kontextinformation nicht, um zu entscheiden, ob Sie diese Datei öffnen und
   bearbeiten möchten. Bash bietet mehrere Kommandos, die Ihnen einen
   schnellen Blick auf den Inhalt einer Textdatei direkt in der Shell
   gestatten, ohne einen Editor zu öffnen.
  </para>

  <variablelist>
   <varlistentry>
    <term><command>head </command>
    </term>
    <listitem>
     <para>
      Mit <command>head </command>können Sie die ersten Zeilen einer Textdatei
      ansehen. Wenn Sie das Kommando nicht weiter spezifizieren, zeigt
      <command>head </command>die ersten zehn Zeilen einer Textdatei.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>tail </command>
    </term>
    <listitem>
     <para>
      Das Kommando <command>tail </command> ist das Gegenstück zu
      <command>head</command>. Wenn Sie <command>tail </command>ohne weitere
      Optionen benutzen, zeigt es die letzten zehn Zeilen einer Textdatei an.
      Dies kann sehr nützlich sein, um Protokolldateien Ihres Systems
      anzusehen, wobei sich die neuesten Meldungen oder Protokolleinträge
      gewöhnlich am Ende der Datei befinden.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>less </command>
    </term>
    <listitem>
     <para>
      Mit <command>less</command> zeigen Sie den ganzen Inhalt einer Textdatei
      an. Mit den Tasten <keycap function="pageup"/> und
      <keycap function="pagedown"/> blättern Sie jeweils um eine halbe Seite.
      Mit <keycap function="space"/> blättern Sie um eine Seite nach unten.
      Mit <keycap function="home"/> gelangen Sie an den Anfang und mit
      <keycap function="end"/> an das Ende des Dokuments. Der Anzeigemodus wird
      mit der Taste <keycap>Q</keycap> beendet.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>more </command>
    </term>
    <listitem>
     <para>
      Statt <literal>less</literal> können Sie auch das ältere Programm
      <literal>more</literal> verwenden. Dies ist im Prinzip dieselbe Funktion,
      jedoch weniger praktisch, da Sie nicht zurückblättern können.
      Verwenden Sie <keycap function="space"/>, um weiter zu blättern. Wenn
      Sie das Ende des Dokuments erreichen, wird der Viewer automatisch
      geschlossen.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>cat </command>
    </term>
    <listitem>
     <para>
      Dieses Kommando gibt den gesamten Inhalt einer Datei ohne Unterbrechung
      auf dem Bildschirm aus. Da <command>cat</command> keinen Bildlauf
      ermöglicht, ist es als Viewer nicht sehr nützlich, wird aber häufig in
      Kombination mit anderen Kommandos verwendet.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec.new.bash.redir">
  <title>Umleitung und Pipes</title>

  <para>
   Manchmal wäre es nützlich, die Ausgabe eines Kommandos zur weiteren
   Bearbeitung in eine Datei zu schreiben oder die Ausgabe eines Kommandos als
   Eingabe für das nächste Kommando zu verwenden. Die Shell bietet diese
   Funktion mithilfe von Umleitungen oder Pipes.
  </para>

  <para>
   Normalerweise ist die Standardausgabe in der Shell der Bildschirm (oder ein
   geöffnetes Shell-Fenster) und die Standardeingabe erfolgt über die
   Tastatur. Mithilfe bestimmter Symbole können Sie die Eingabe bzw. Ausgabe
   an ein anderes Objekt, beispielsweise eine Datei oder ein anderes Kommando,
   umleiten.
  </para>

  <variablelist>
   <varlistentry>
    <term>Umadressierung</term>
    <listitem>
     <para>
      Mit <literal>&gt;</literal> können Sie die Ausgabe eines Kommandos in
      eine Datei weiterleiten (Ausgabeumleitung). Mit
      <literal>&lt;</literal> können Sie eine Datei als Eingabe für ein
      Kommando verwenden (Eingabeumleitung).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Pipe</term>
    <listitem>
     <para>
      Mithilfe eines Pipe-Symbols <literal>|</literal> können Sie zudem die
      Ausgabe umleiten. Mit einer Pipe können Sie mehrere Kommandos
      kombinieren, wobei die Ausgabe eines Kommandos als Eingabe für das
      nächste Kommando verwendet wird. Im Unterschied zu den anderen
      Umleitungssymbolen &gt; und &lt; ist die Verwendung der Pipe nicht
      auf Dateien beschränkt.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <sect2 xml:id="sec.new.bash.redir.ex">
   <title>Beispiele für Umleitung und Pipe</title>
   <procedure>
    <step>
     <para>
      Sie schreiben die Ausgabe eines Kommandos wie <command>ls </command> in
      eine Datei, indem Sie Folgendes eingeben:
     </para>
<screen>ls -l &gt; filelist.txt</screen>
     <para>
      Dadurch wird eine Datei mit dem Namen <filename>filelist.txt </filename>
      erstellt, die eine Inhaltsliste des aktuellen Verzeichnisses enthält,
      welche Sie durch das Kommando <command>ls </command> erzeugt haben.
     </para>
     <para>
      Wenn jedoch bereits eine Datei mit dem Namen <filename>filelist.txt
      </filename> vorhanden ist, wird mit diesem Kommando die bestehende Datei
      überschrieben. Sie können dies mit <literal>&gt;&gt;</literal>
      anstelle von &gt; verhindern. Wenn Sie Folgendes eingeben:
     </para>
<screen>ls -l &gt;&gt; filelist.txt </screen>
     <para>
      wird die Ausgabe des Kommandos <command>ls </command> einfach an eine
      bereits bestehende Datei mit dem Namen <filename>filelist.txt </filename>
      angehängt. Wenn die Datei nicht vorhanden ist, wird sie erstellt.
     </para>
    </step>
    <step>
     <para>
      Die Umleitung funktioniert auch umgekehrt. Anstelle einer Standardeingabe
      für ein Kommando auf der Tastatur können Sie eine Datei als Eingabe
      verwenden:
     </para>
<screen>sort &lt; filelist.txt</screen>
     <para>
      Dadurch wird das Kommando <command>Sortieren</command> gezwungen, die
      Eingabe aus dem Inhalt der Datei <filename>filelist.txt</filename>
      abzurufen. Das Ergebnis wird am Bildschirm angezeigt. Sie können das
      Ergebnis natürlich auch in eine andere Datei schreiben, indem Sie eine
      Kombination aus Umleitungen verwenden:
     </para>
<screen>sort  &lt; filelist.txt &gt; sorted_filelist.txt</screen>
    </step>
    <step>
     <para>
      Wenn ein Kommando eine längere Ausgabe erzeugt, wie zum Beispiel
      <command>ls</command> <option>-l</option>, kann es nützlich sein, die
      Ausgabe an einen Viewer wie <literal>less</literal> weiterzuleiten, damit
      Sie durch die Seiten blättern können. Geben Sie dazu Folgendes ein:
     </para>
<screen>ls -l | less</screen>
     <para>
      Die Inhaltsliste für das aktuelle Verzeichnis wird in <literal>less
      </literal> angezeigt.
     </para>
     <para>
      Die Pipe wird auch häufig in Kombination mit dem Kommando <command>grep
      </command> verwendet, um eine bestimmte Zeichenfolge in der Ausgabe eines
      anderen Kommandos zu suchen. Wenn Sie beispielsweise eine Liste von
      Dateien in einem Verzeichnis sehen möchten, dessen Eigentümer der
      Benutzer &exampleuser; ist, geben Sie Folgendes ein:
     </para>
<screen>ls -l | grep tux</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.new.bash.jobs">
  <title>Starten von Programmen und Verarbeiten von Prozessen</title><indexterm>

  <primary>Shell</primary>

  <secondary>Prozesse</secondary></indexterm><indexterm>

  <primary>Bash</primary>

  <secondary>Prozesse</secondary></indexterm><indexterm>

  <primary>Shell</primary>

  <secondary>Aufträge</secondary></indexterm><indexterm>

  <primary>Bash</primary>

  <secondary>Aufträge</secondary></indexterm><indexterm>

  <primary>Prozesse</primary>

  <secondary>Shell</secondary></indexterm><indexterm>

  <primary>Aufträge</primary>

  <secondary>Shell</secondary></indexterm>

  <para>
   Wie unter <xref linkend="sec.new.bash.edit"/> erläutert, können Programme
   über die Shell gestartet werden. Anwendungen mit einer grafischen
   Bedienoberfläche benötigen das X Windows System und können nur von einem
   Terminalfenster in einer grafischen Bedienoberfläche gestartet werden. Wenn
   beispielsweise eine Datei namens <filename>vacation.pdf</filename> in Ihrem
   Home-Verzeichnis in KDE oder GNOME über ein Terminalfenster geöffnet
   werden soll, führen Sie einfach
   <command>okular&nbsp;~/vacation.pdf</command> (oder <command>evince
   ~/vacation.pdf</command>) aus, um einen PDF-Viewer zur Anzeige Ihrer Datei
   zu starten.
  </para>

  <para>
   Beim erneuten Blick auf das Terminalfenster fällt auf, dass die
   Kommandozeile gesperrt ist, solange der PDF-Viewer geöffnet ist, es gibt
   also keine Eingabeaufforderung. Wenn Sie dies ändern möchten, drücken Sie
   <keycombo> <keycap function="control"/> <keycap>Z</keycap> </keycombo>, um
   den Prozess auszusetzen, und geben Sie <indexterm>
   <primary>Kommandos</primary>
   <secondary>bg</secondary>
   </indexterm> <command>bg</command> ein, um den Prozess in den Hintergrund zu
   verlagern. Jetzt können Sie <filename>vacation.pdf</filename> weiterhin
   betrachten und die Eingabeaufforderung ist für weitere Kommandos
   verfügbar. Noch einfacher lässt sich dies erreichen, wenn Sie den Prozess
   gleich beim Starten in den Hintergrund verlagern. Fügen Sie hierzu am Ende
   des Kommandos ein Kaufmanns-Und (&amp;) an.
  </para>

<screen>okular ~/vacation.pdf &amp;</screen>

  <para>
   Wenn Sie mehrere Hintergrundprozesse (auch Aufträge genannt) über dieselbe
   Shell gestartet haben, erhalten Sie über das Kommando
   <command>jobs</command><indexterm>
   <primary>Kommando</primary>
   <secondary>jobs</secondary>
   </indexterm> einen Überblick über die Aufträge. Es wird auch die
   Auftragsnummer in Klammern sowie der jeweilige Status angezeigt:
  </para>

<screen><?dbsuse-fo font-size="0.80em"?>tux@linux:~&gt; jobs
[1]   Running        okular book.opensuse.startup-xep.pdf &amp;
[2]-  Running        okular book.opensuse.reference-xep.pdf &amp;
[3]+  Stopped        man jobs</screen>

  <para>
   Wenn ein Auftrag wieder im Vordergrund angezeigt werden soll, geben Sie
   <indexterm>
   <primary>Kommandos</primary>
   <secondary>fg</secondary>
   </indexterm> <command>fg</command> <replaceable>JOB_NUMMER</replaceable>.
   ein.
  </para>

  <para>
   <indexterm>
   <primary>Kommandos</primary>
   <secondary>ps</secondary>
   </indexterm> Während mit <command>job</command> lediglich die über eine
   spezifische Shell gestarteten Hintergrundprozesse angezeigt werden, wird mit
   dem Kommando <command>ps</command> (bei Ausführung ohne Optionen) eine
   Liste all Ihrer Prozesse angezeigt, also all der Prozesse, die von Ihnen
   gestartet wurden. Hier ein Beispiel für eine Ausgabe:
  </para>

<screen>tux@linux:~&gt; ps
PID TTY          TIME CMD
15500 pts/1    00:00:00 bash
28214 pts/1    00:00:00 okular
30187 pts/1    00:00:00 kwrite
30280 pts/1    00:00:00 ps</screen>

  <para>
   <indexterm>
   <primary>Kommandos</primary>
   <secondary>kill</secondary>
   </indexterm> Wenn ein Programm nicht normal beendet werden kann, verwenden
   Sie das Kommando <command>kill</command>, um den Prozess (bzw. die Prozesse)
   zu stoppen, die zu diesem Programm gehören. Geben Sie hierzu die Prozess-ID
   (PID) an, die aus der Ausgabe von <command>ps</command> hervorgeht. Geben
   Sie zum Beenden des KWrite-Editors im obigen Beispiel beispielsweise
   Folgendes ein:
  </para>

<screen>kill 30187</screen>

  <para>
   Hiermit wird ein <emphasis>TERM</emphasis>-Signal gesendet, dass das
   Programm zum selbsttätigen Beenden anweist.
  </para>

  <para>
   Alternative: Wenn es sich bei dem Programm oder Prozess, das/den Sie beenden
   möchten, um einen Hintergrundauftrag handelt, der zudem mithilfe des
   Kommandos <command>jobs</command> angezeigt werden kann, können Sie auch
   das Kommando <command>kill</command> in Kombination mit der Auftragsnummer
   verwenden, um diesen Prozess zu beenden. Wenn Sie den Auftrag mit einer
   Auftragsnummer kennzeichnen, muss der Nummer ein Prozentzeichen
   (<literal>&percnt;</literal>) vorangestellt werden:
  </para>

<screen>kill %<replaceable>JOB_NUMMER</replaceable></screen>

  <para>
   Falls <command>kill</command> nicht zum gewünschten Ergebnis führt
   &ndash; wie dies manchmal bei Programmen der Fall ist, die nicht mehr
   reagieren &ndash; versuchen Sie es hiermit: <quote/>
  </para>

<screen>kill -9 <replaceable>PID</replaceable></screen>

  <para>
   Hiermit wird anstelle des <emphasis>KILL</emphasis>-Signals ein
   <emphasis>TERM</emphasis>-Signal gesendet, mit dem sich der Prozess in
   nahezu allen Fällen beenden lässt.
  </para>

  <para>
   Dieser Abschnitt dient der Einführung in die grundlegendsten Kommandos zur
   Verarbeitung von Aufträgen und Prozessen. Eine Übersicht für
   Systemadministratoren finden Sie unter <link xlink:href="https://doc.opensuse.org/documentation/leap/tuning/html/book-sle-tuning/cha-util.html#sec-util-processes">Processes</link>.
  </para>
 </sect1>
 <xi:include href="newbie_bash_commands_i.xml" parse="xml"/>
</chapter>
