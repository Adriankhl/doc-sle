<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="hardware_nvdimm.xml" version="5.0" xml:id="cha-nvdimm">
 <title>Permanenter Speicher</title>
 <info>
  <abstract>
   <para>
    Dieses Kapitel enthält weitere Informationen zur Verwendung von <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> mit nicht-flüchtigem Hauptspeicher, auch als <emphasis>Permanenter Speicher</emphasis> bekannt, der aus einem oder mehreren NVDIMM besteht.
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>Ja</dm:translation>
  </dm:docmanager>
 </info>
 <sect1 xml:id="sec-nvdimm-intro">
  <title>Einführung</title>

  <para>
   Ein permanenter Speicher ist eine neue Art von Speicherung am Rechner. Er kombiniert annähernd so hohe Geschwindigkeiten wie bei normalen dynamischen RAMs (DRAMs) mit der Byte-für-Byte-Adressierbarkeit des RAM und der Permanenz von Solid-State Disks (SSDs).
  </para>

  <para>
   Wie bei herkömmlichen RAMs wird er direkt am Speichersteckplatz der Hauptplatine installiert. Damit wird er im selben physischen Formfaktor bereitgestellt wie RAM – als DIMMs. Man nennt sie NVDIMMs: Non-Volatile Dual Inline Memory Modules.
  </para>

  <para>
   Im Unterschied zu RAM ist ein permanenter Speicher in vielerlei Hinsicht Flash-basierten SSDs ähnlich. Beide basieren auf unterschiedliche Weise auf dem Stromkreis von Festkörperspeichern, bieten aber unabhängig davon einen nicht-flüchtigen Speicher. Dies bedeutet, dass ihre Inhalte beibehalten werden, wenn das System heruntergefahren oder neu gestartet wird. Bei beiden Varianten geht das Schreiben von Daten langsamer von statten als das Lesen und beide unterstützen eine begrenzte Anzahl von Neuschreibungszyklen. Wie bei SSDs ist der Zugriff auf Sektorebene des permanenten Speichers möglich, sollte dies für eine bestimmte Anwendung erforderlich sein.
  </para>


  <para>
   Die unterschiedlichen Modelle verwenden verschiedene Arten von elektronischen Speichermedien, wie Intel 3D XPoint oder eine Kombination aus NAND-Flash und DRAM. Neue Arten von nicht-flüchtigen RAMs werden derzeit entwickelt. Verschiedene Anbieter und Modelle von NVDIMMs bieten unterschiedliche Eigenschaften für Leistung und Langlebigkeit.
  </para>
  
  <para>
   Da sich die entsprechenden Speichertechnologien noch in der frühen Entwicklungsphase befinden, ist bei der Hardware verschiedener Anbieter möglicherweise mit unterschiedlichen Einschränkungen zu rechnen. Daher sind die folgenden Aussagen als Verallgemeinerungen zu betrachten.
  </para>
  
  <para>
   Ein permanenter Speicher ist bis zu zehn mal langsamer als DRAM, doch in etwa tausend mal schneller als Flash-Speicher. Im Gegensatz zum Vorgang des Auslöschens und Neuschreibens des gesamten Sektors beim Flash-Speicher kann der permanente Speicher auf Byte-zu-Byte-Basis neu geschrieben werden. Da die Neuschreibungszyklen begrenzt sind, können permanente Speicher schließlich Millionen von Neuschreibungen verarbeiten, verglichen mit Tausenden von Zyklen des Flash-Speichers.
  </para>

  <para>
   Das hat zwei erhebliche Folgen:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     Beim aktuellen Stand der Technik ist es nicht möglich, ein System nur mit permanentem Speicher auszuführen und dadurch einen gänzlich nicht-flüchtigen Hauptspeicher zu erzielen. Sie müssen einen herkömmlichen RAM mit NVDIMMs kombinieren. Das Betriebssystem und die Anwendungen werden am herkömmlichen RAM ausgeführt und NVDIMMs bieten eine sehr schnelle ergänzende Speichermöglichkeit.
    </para>
   </listitem>
   <listitem>
    <para>
     Aufgrund der Leistungsmerkmale der permanenten Speicher von verschiedenen Anbietern müssen Programmierer möglicherweise die Hardwarespezifikationen der NVDIMMs an einem bestimmten Server berücksichtigen, einschließlich deren Anzahl und belegten Speichersteckplätze. Dies wirkt sich offensichtlich auf die Verwendung des Hypervisors aus sowie auf die Migration von Software zwischen verschiedenen Host-Rechnern usw.
    </para>
   </listitem>
  </itemizedlist>
  
  <para>
   Dieses neue Speicher-Untersystem ist in Version 6 des ACPI-Standards definiert. <filename>libnvdimm</filename> unterstützt jedoch NVDIMMs, die den Standard noch nicht erfüllen, wodurch diese auf gleiche Weise verwendet werden können.
  </para>
  
 </sect1>
 <sect1 xml:id="sec-nvdimm-terms">
  <title>Begriffe</title>

  <variablelist>
   <varlistentry>
    <term>Region</term>
    <listitem>
     <para>
      Eine <emphasis>Region</emphasis> ist ein Block des permanenten Speichers, der in einen oder mehrere <emphasis>Namespace</emphasis>s unterteilt werden kann. Der Zugriff auf den permanenten Speicher einer Region ist erst nach dessen Zuordnung zu einem Namespace möglich.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Namespace</term>
    <listitem>
     <para>
      Ein einzelner zusammenhängend adressierter Bereich eines nicht-flüchtigen Speichers, vergleichbar mit NVM Express SSD-Namespaces oder SCSI Logical Units (LUNs). Namespaces werden im <filename>/dev</filename>-Verzeichnis des Servers als separate Blockgeräte angezeigt. Abhängig von der erforderlichen Zugriffsmethode können Namespaces entweder Speicherplatz von verschiedenen NVDIMMs in größere Volumes zusammenfassen oder dessen Partitionierung in kleinere Volumes zulassen.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Modus</term>
    <listitem>
     <para>
      Jeder Namespace weist einen <emphasis>Modus</emphasis> auf, der definiert, welche NVDIMM-Funktionen für diesen Namespace aktiviert sind. Gleichgeordnete Namespaces der selben übergeordneten Region sind im Typ immer gleich, werden jedoch möglicherweise mit verschiedenen Modi konfiguriert. Namespace-Modi:
     </para>
     <variablelist>
      <varlistentry>
       <term>raw</term>
       <listitem>
        <para>
         Speichermedium. Keine Unterstützung von DAX. Kompatibel mit anderen Betriebssystemen.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>sector</term>
       <listitem>
        <para>
         Für veraltete Dateisysteme, die keine Checksumme für Metadaten erstellen. Geeignet für kleine Boot-Volumes. Kompatibel mit anderen Betriebssystemen.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>fsdax</term>
       <listitem>
        <para>
         Dateisystem-DAX-Modus. Standardmodus, falls kein anderer Modus angegeben wird. Erstellt ein Blockgerät (<filename>/dev/pmem<replaceable>X</replaceable> [.<replaceable>Y</replaceable>]</filename>), das DAX für <literal>ext4</literal> oder <literal>XFS</literal> unterstützt.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>devdax</term>
       <listitem>
        <para>
         Geräte-DAX-Modus. Erstellt eine Einzelzeichen-Gerätedatei (<filename> /dev/dax<replaceable>X</replaceable>.<replaceable>Y</replaceable>
         </filename>). Die Erstellung eines Dateisystems ist <emphasis>nicht</emphasis> erforderlich.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>
   
   <varlistentry>
    <term>Typ</term>
    <listitem>
     <para>
      Jeder Namespace und jede Region weist einen <emphasis>Typ</emphasis> auf, der definiert, auf welche Weise auf den permanenten Speicher, der mit diesem Namespace oder dieser Region verknüpft ist, zugegriffen wird. Ein Namespace hat immer denselben Typ wie dessen übergeordnete Region. Es gibt zwei verschiedene Typen: den permanenten Speicher und den Block-Modus.
     </para>
     <variablelist>
      <varlistentry>
       <term>Permanenter Speicher (PMEM)</term>
       <listitem>
        <para>
         Der PMEM-Speicher bietet Zugriff auf Byte-Ebene, genauso wie RAM. Hiermit wird der Direktzugriff (DAX) aktiviert. Der Zugriff auf den Speicher umgeht also den Seiten-Cache des Kernels und gelangt direkt zum Speichermedium. Mit PMEM kann zudem ein einzelner Namespace mehrere überlappende NVDIMMs enthalten und auf alle kann jeweils als Einzelgerät zugegriffen werden.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Block-Modus (BLK)</term>
       <listitem>
        <para>
         Der BLK-Zugriff erfolgt in Sektoren (meist 512 Byte) über ein definiertes Zugriffsfenster, die sogenannte <emphasis>Apertur</emphasis>. Dieses Verhalten entspricht eher einem herkömmlichen Festplattenlaufwerk. Dies bedeutet außerdem, dass sowohl Lese- als auch Schreibvorgänge im Kernel zwischengespeichert werden. Beim BLK-Zugriff erfolgt der Zugriff auf die einzelnen NVDIMM jeweils als separater Namespace.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     <para>
      Einige Geräte unterstützen sowohl den PMEM- als auch den BLK-Modus. Darüber hinaus kann in einigen Fällen auch der Speicher in separate Namespaces aufgeteilt werden, sodass der Zugriff auf einige Namespaces über PMEM, auf andere dagegen über BLK erfolgen kann.
     </para>
     <para>
      Mit Ausnahme von <literal>devdax</literal>-Namespaces müssen alle Typen mit einem Dateisystem wie <literal>ext2</literal>, <literal>ext4</literal> oder <literal>XFS</literal> formatiert werden, wie ein herkömmliches Laufwerk.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Direktzugriff (Direct Access, DAX)</term>
    <listitem>
     <para>
      Durch DAX kann ein permanenter Speicher direkt im Adressbereich eines Prozesses zugeordnet werden, beispielsweise über den Systemaufruf <literal>mmap. </literal> Dies ist ideal für den direkten Zugriff auf große PMEM-Mengen ohne zusätzliches RAM, zum Registrieren von PMEM-Blöcken für RDMA sowie für die direkte Zuweisung zu virtuellen Computern. 
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Physikalische DIMM-Adresse (DPA)</term>
    <listitem>
     <para>
      Eine Speicheradresse als Offset in den Speicher eines einzelnen DIMMs, das heißt beginnend bei Null als niedrigstem adressierbaren Byte in diesem DIMM.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Kennung</term>
    <listitem>
     <para>
      Im NVDIMM gespeicherte Metadaten wie beispielsweise Namespace-Definitionen. Der Zugriff ist über DSM möglich.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Gerätespezifische Methode (Device-specific method, DSM)</term>
    <listitem>
     <para>
      ACPI-Methode für den Zugriff auf die Firmware eines NVDIMM.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 
 <sect1 xml:id="sec-nvdimm-uses">
  <title>Anwendungsfälle</title>
  <sect2 xml:id="sec-nvdimm-uses-pmem">
   <title>PMEM mit DAX</title>
   <para>
    Es ist wichtig zu wissen, dass diese Art von Speicherzugriff <emphasis>keine</emphasis> Transaktion ist. Im Fall eines Stromausfalls oder eines anderen Systemfehlers werden die Daten möglicherweise nicht vollständig in den Speicher geschrieben. Ein PMEM-Speicher ist nur für Anwendungen geeignet, die teilweise geschriebene Daten verarbeiten können.
   </para>
   <sect3>
    <title>
     Anwendungen, die von einem großen Byte-adressierbaren Speicher profitieren.
    </title> 
    <para>
     Wenn am Server eine Anwendung gehostet wird, die direkt einen großen Teil eines schnellen Speichers Byte für Byte verwendet, kann der Programmierer mit dem Systemaufruf <literal>mmap</literal> Blöcke des permanenten Speichers direkt in den Adressbereich der Anwendung stellen, ohne auf zusätzlichen System-RAM zurückgreifen zu müssen. 
    </para>
   </sect3>
   <sect3>
    <title>Vermeiden des Kernel-Seiten-Cache</title>
    <para>
     Wenn Sie den RAM für den Seiten-Cache aufsparen und den nicht-flüchtigen Speicher anderen Anwendungen zuweisen möchten. Dieser könnte beispielsweise zum Speichern von VM-Images vorgesehen werden. Diese Images würden nicht in den Cache gestellt werden, was die Cache-Auslastung am Host reduzieren und mehr VMs pro Host zulassen würde.
    </para>
   </sect3>
  </sect2>
  <sect2>
   <title>PMEM mit BTT</title>
   <para>
    Diese Variante ist nützlich, wenn Sie den permanenten Speicher auf einigen NVDIMMs als einen Datenträger-ähnlichen Pool von sehr schnellen Speichern verwenden möchten.
   </para>
   <para>
    Anwendungen halten diese Geräte für sehr schnelle SSDs, die wie jedes andere Speichergerät verwendet werden. LVM kann beispielsweise auf den nichtflüchtigen Speicher aufgesetzt werden und funktioniert normal.
   </para>
   <para>
    BTT hat den Vorteil, dass die Unteilbarkeit beim Schreiben in den Sektor gewährleistet ist. Somit bleiben sogar sehr anspruchsvolle und von Datenintegrität abhängige Anwendungen funktionsfähig. Die Erstellung von Fehlerberichten funktioniert über standardmäßige Kanäle zur Fehlerberichterstellung.
   </para>
  </sect2>
  <sect2>
   <title>BLK-Speicher</title>
   <para>
    Dieser Speicher ist weniger anfällig gegenüber dem Ausfall einzelner Geräte, verursacht jedoch zusätzlichen Verwaltungsaufwand, da jedes NVDIMM als separates Gerät angezeigt wird. PMEM mit BTT ist daher im Allgemeinen vorzuziehen.
   </para>
   <note>
    <para>
     Der BLK-Speicher wird nicht mehr verwendet und in künftigen Versionen von <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> nicht unterstützt.
    </para>
   </note>
  </sect2>
 </sect1>
 
 <sect1 xml:id="sec-nvdimm-tools">
  <title>Tools zur Verwaltung von permanenten Speichern</title>

  <para>
   Zur Verwaltung eines permanenten Speichers muss das Paket <literal>ndctl</literal> installiert werden. Dadurch wird auch das Paket <filename>libndctl</filename> installiert. Es enthält einige Benutzerbereich-Bibliotheken zum Konfigurieren von NVDIMMs.
  </para>

  <para>
   Diese Tools arbeiten mit der Bibliothek <filename>libnvdimm</filename>, die drei Typen von NVDIMMs unterstützt:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     PMEM
    </para>
   </listitem>
   <listitem>
    <para>
     BLK
    </para>
   </listitem>
   <listitem>
    <para>
     PMEM und BLK gleichzeitig
    </para>
   </listitem>
  </itemizedlist>

  <para>
   Das <command>ndctl</command>-Dienstprogramm enthält einige nützliche <command>man</command>-Seiten, auf die mit dem folgenden Kommando zugegriffen wird:
  </para>

<screen><command>ndctl help <replaceable>subcommand</replaceable></command></screen>

  <para>
   Eine Liste der verfügbaren Unterkommandos erhalten Sie mit:
  </para>

<screen><command>ndctl --list-cmds</command></screen>

  <para>
   Folgende Unterkommandos stehen zur Verfügung:
  </para>

  <variablelist>
   <varlistentry>
    <term>version</term>
    <listitem>
     <para>
      Zeigt die aktuelle Version der NVDIMM-Unterstützungstools an.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>enable-namespace</term>
    <listitem>
     <para>
      Stellt den angegebenen Namespace zur Verfügung.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>disable-namespace</term>
    <listitem>
     <para>
      Verhindert die Verwendung des angegebenen Namespace.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>create-namespace</term>
    <listitem>
     <para>
      Erstellt einen neuen Namespace aus den angegebenen Speichergeräten.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>destroy-namespace</term>
    <listitem>
     <para>
      Entfernt den angegebenen Namespace.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>enable-region</term>
    <listitem>
     <para>
      Stellt die angegebene Region zur Verfügung.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>disable-region</term>
    <listitem>
     <para>
      Verhindert die Verwendung der angegebenen Region.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>zero-labels</term>
    <listitem>
     <para>
      Löscht die Metadaten von einem Gerät.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>read-labels</term>
    <listitem>
     <para>
      Ruft die Metadaten vom angegebenen Gerät ab.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>list</term>
    <listitem>
     <para>
      Zeigt verfügbare Geräte an.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>help</term>
    <listitem>
     <para>
      Zeigt Informationen zur Verwendung des Tools an.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec-nvdimm-setup">
  <title>Einrichten eines permanenten Speichers</title>

  <sect2 xml:id="sec-nvdimm-setup-view">
   <title>Anzeigen des verfügbaren NVDIMM-Speichers</title>
   <para>
    Mit dem Kommando <command>ndctl</command> <literal>list</literal> werden alle verfügbaren NVDIMMs in einem System aufgelistet.
   </para>
   <para>
    Im folgenden Beispiel hat das System drei NVDIMMs, die sich in einem einzelnen, dreikanaligen überlappenden Set befinden.
   </para>
<screen><prompt role="root">root # </prompt><command>ndctl list --dimms</command>

[
 {
  "dev":"nmem2",
  "id":"8089-00-0000-12325476"
 },
 {
  "dev":"nmem1",
  "id":"8089-00-0000-11325476"
 },
 {
  "dev":"nmem0",
  "id":"8089-00-0000-10325476"
 }
]</screen>
   <para>
    Mit einem anderen Parameter listet <command>ndctl</command>
    <literal>list</literal> auch die verfügbaren Regionen auf.
   </para>
   <note>
    <para>
     Regionen erscheinen möglicherweise nicht in numerischer Reihenfolge.
    </para>
   </note>
   <para>
    Beachten Sie, dass zwar nur drei NVDIMMs vorhanden sind, doch vier Regionen angezeigt werden.
   </para>
<screen><prompt role="root">root # </prompt><command>ndctl list --regions</command>

[
 {
  "dev":"region1",
  "size":68182605824,
  "available_size":68182605824,
  "type":"blk"
 },
 {
  "dev":"region3",
  "size":202937204736,
  "available_size":202937204736,
  "type":"pmem",
  "iset_id":5903239628671731251
  },
  {
   "dev":"region0",
   "size":68182605824,
   "available_size":68182605824,
   "type":"blk"
  },
  {
   "dev":"region2",
   "size":68182605824,
   "available_size":68182605824,
   "type":"blk"
  }
]</screen>
   <para>
    Der Speicherplatz ist auf zwei verschiedene Arten verfügbar: entweder als drei separate 64 GB-Regionen vom Typ BLK oder als eine kombinierte 189 GB-Region vom Typ PMEM, die den gesamten Speicherplatz auf den drei überlappenden NVDIMMs als ein einziges Volume darstellt.
   </para>
   <para>
    Beachten Sie, dass der angezeigte Wert für <literal>available_size</literal> identisch ist mit dem Wert für <literal>size</literal>. Dies bedeutet, dass noch kein Speicherplatz zugeordnet wurde.
   </para>
  </sect2>

  <sect2 xml:id="sec-nvdimm-setup-dax">
   <title>Konfigurieren des Speichers als einzelnen PMEM-Namespace mit DAX</title>
   <para>
    Im ersten Beispiel konfigurieren wir unsere drei NVDIMMs in einem einzelnen PMEM-Namespace mit Direktzugriff (DAX).
   </para>
   <para>
    Im ersten Schritt erstellen wir einen neuen Namespace.
   </para>
   
<screen><prompt role="root">root # </prompt><command>ndctl create-namespace --type=<replaceable>pmem</replaceable> --mode=<replaceable>fsdax</replaceable> --map=<replaceable>memory</replaceable></command>
{
 "dev":"namespace3.0",
 "mode":"memory",
 "size":199764213760,
 "uuid":"dc8ebb84-c564-4248-9e8d-e18543c39b69",
 "blockdev":"pmem3"
}</screen>
   <para>
    Dadurch wird ein Blockgerät <filename>/dev/pmem3</filename> erstellt, das DAX unterstützt. Die <literal>3</literal> im Gerätenamen wird von der Nummer der übergeordneten Region übernommen, in diesem Fall <filename>region3</filename>.
   </para>
   <para>
    Die Option <option>--map=memory</option> reserviert einen Teil des PMEM-Speicherplatzes auf den NVDIMMs für die Zuordnung interner Kernel-Datenstrukturen namens <literal>struct pages</literal>. Dadurch kann der neue PMEM-Namespace mit Funktionen wie <literal>O_DIRECT I/O</literal> und <literal>RDMA</literal> verwendet werden.
   </para>
   <para>
    Aufgrund der Reservierung eines Teils des permanenten Speichers für Kernel-Datenstrukturen hat der resultierende PMEM-Namespace eine geringere Kapazität als die übergeordnete PMEM-Region.
   </para>
   <para>
    Als nächstes überprüfen wir, ob das neue Blockgerät für das Betriebssystem verfügbar ist:
   </para>
<screen><prompt role="root">root # </prompt><command>fdisk -l /dev/<replaceable>pmem3</replaceable></command>
Disk /dev/pmem3: 186 GiB, 199764213760 bytes, 390164480 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes</screen>
   <para>
    Bevor es verwendet werden kann, muss es wie jedes andere Gerät formatiert werden. In diesem Beispiel formatieren wir es mit XFS:
   </para>
<screen><prompt role="root">root # </prompt><command>mkfs.xfs /dev/<replaceable>pmem3</replaceable></command>
meta-data=/dev/pmem3      isize=256    agcount=4, agsize=12192640 blks
         =                sectsz=4096  attr=2, projid32bit=1
         =                crc=0        finobt=0, sparse=0
data     =                bsize=4096   blocks=48770560, imaxpct=25
         =                sunit=0      swidth=0 blks
naming   =version 2       bsize=4096   ascii-ci=0 ftype=1
log      =internal log    bsize=4096   blocks=23813, version=2
         =                sectsz=4096  sunit=1 blks, lazy-count=1
realtime =none            extsz=4096   blocks=0, rtextents=0</screen>
   <para>
    Danach können wir das neue Laufwerk in ein Verzeichnis einhängen:
   </para>
<screen><prompt role="root">root # </prompt><command>mount -o dax /dev/<replaceable>pmem3</replaceable> /mnt/<replaceable>pmem3</replaceable></command></screen>
   <para>
    Dann überprüfen wir, ob wir nun über ein DAX-fähiges Gerät verfügen:
   </para>
<screen><prompt role="root">root # </prompt><command>mount | grep dax</command>
/dev/pmem3 on /mnt/pmem3 type xfs (rw,relatime,attr2,dax,inode64,noquota)</screen>
   <para>
    Das Ergebnis ist ein PMEM-Namespace, der mit dem XFS-Dateisystem formatiert und mit DAX eingehängt ist.
   </para>
   <para>
    <literal>mmap()</literal>-Aufrufe von Dateien in diesem Dateisystem geben virtuelle Adressen zurück, die direkt dem permanenten Speicher auf unseren NVDIMMs zugeordnet werden. Der Seiten-Cache wird dabei voll umgangen.
   </para>
   <para>
    <literal>fsync</literal>- oder <literal>msync</literal>-Aufrufe von Dateien in diesem Dateisystem stellen weiterhin sicher, dass geänderte Daten vollständig in die NVDIMMs geschrieben werden. Diese Aufrufe löschen die Zeilen des Prozessor-Cache, die mit Seiten verknüpft sind, die im Benutzerbereich über <literal>mmap</literal>-Zuordnungen geändert wurden.
   </para>
   <sect3 xml:id="sec-nvdimm-setup-deldax">
    <title>Entfernen eines Namespace</title>
    <para>
     Bevor wir einen anderen Volume-Typ erstellen, der den selben Speicher verwendet, müssen wir das PMEM-Volume aushängen und dann entfernen.
    </para>
    <para>
     Hängen Sie es zunächst aus:
    </para>
<screen><prompt role="root">root # </prompt><command>umount /mnt/<replaceable>pmem3</replaceable></command></screen>
    <para>
     Deaktivieren Sie dann den Namespace:
    </para>
<screen><prompt role="root">root # </prompt><command>ndctl disable-namespace <replaceable>namespace3.0</replaceable></command>
disabled 1 namespace</screen>
    <para>
     Löschen Sie es nun:
    </para>
<screen><prompt role="root">root # </prompt><command>ndctl destroy-namespace <replaceable>namespace3.0</replaceable></command>
destroyed 1 namespace</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-nvdimm-setup-btt">
   <title>Erstellen eines PMEM-Namespace mit BTT</title>
   <para>
    Im nächsten Beispiel erstellen wir einen PMEM-Namespace, der BTT verwendet.
   </para>
<screen><prompt role="root">root # </prompt><command>ndctl create-namespace --type=<replaceable>pmem</replaceable> --mode=<replaceable>sector</replaceable></command>
{
 "dev":"namespace3.0",
 "mode":"sector",
 "uuid":"51ab652d-7f20-44ea-b51d-5670454f8b9b",
 "sector_size":4096,
 "blockdev":"pmem3s"
}</screen>
   <para>
    Überprüfen Sie als nächstes, ob das Gerät vorhanden ist:
   </para>
<screen><prompt role="root">root # </prompt><command>fdisk -l /dev/<replaceable>pmem3s</replaceable></command>
Disk /dev/pmem3s: 188.8 GiB, 202738135040 bytes, 49496615 sectors
Units: sectors of 1 * 4096 = 4096 bytes
Sector size (logical/physical): 4096 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes</screen>
   <para>
    Wie der vorher konfigurierte DAX-fähige PMEM-Namespace verbraucht dieser BTT-fähige Namespace den gesamten verfügbaren Speicherplatz auf den NVDIMMs.
   </para>
   <note>
    <para>
     Das angehängte <literal>s</literal> am Ende des Gerätenamens (<filename>/dev/<replaceable>pmem3s</replaceable></filename>) steht für <literal>sector</literal>. Damit lassen sich PMEM- und BLK-Namespaces, die zur Verwendung von BTT konfiguriert wurden, leicht unterscheiden.
    </para>
   </note>
   <para>
    Das Volume wird wie im vorigen Beispiel formatiert und eingehängt.
   </para>
   <para>
    Der hier gezeigte PMEM-Namespace kann DAX nicht verwenden. Stattdessen verwendet er BTT für die <emphasis>Unteilbarkeit beim Schreiben des Sektors</emphasis>. Bei jedem Schreiben des Sektors über den PMEM-Blocktreiber ordnet BTT einen neuen Sektor zu, um neue Daten zu empfangen. BTT aktualisiert ungeteilt die internen Zuordnungsstrukturen, nachdem alle neuen Daten vollständig geschrieben sind, sodass die neu geschriebenen Daten den Anwendungen zur Verfügung stehen. Wenn zu irgendeinem Zeitpunkt dieses Vorgangs der Strom ausfällt, sind alle geschriebenen Daten verloren und die Anwendung hat Zugriff auf die alten Daten, die noch intakt sind. Dadurch wird der Zustand der sogenannten „zerrissenen Sektoren“ verhindert.
   </para>
   <para>
    Dieser BTT-fähige PMEM-Namespace wird wie ein Dateisystem formatiert und verwendet, genau wie jedes andere Standard-Blockgerät. Die Verwendung mit DAX ist nicht möglich. <literal>mmap</literal>-Zuordnungen für Dateien auf diesem Blockgerät verwenden jedoch den Seiten-Cache.
   </para>
   <note>
    <para>
     In beiden Beispielen wird der Speicherplatz aus allen NVDIMMs in einem einzigen Volume kombiniert. Wenn ein Fehler bei einem einzelnen NVDIMM auftritt, geht daher möglicherweise der Inhalt des gesamten Volumes verloren, wie bei einem nicht redundanten Disk-Array. Je mehr NVDIMMs sich im Volume befinden, desto höher ist die Gefahr eines solchen Fehlers.
    </para>
   </note>
   <sect3 xml:id="sec-nvdimm-setup-delbtt">
    <title>Entfernen des PMEM-Volumes</title>
    <para>
     Wie im vorherigen Beispiel müssen zunächst das Volume und der Namespace entfernt werden, bevor der Speicherplatz neu zugewiesen werden kann:
    </para>
<screen><prompt role="root">root # </prompt><command>ndctl disable-namespace <replaceable>namespace3.0</replaceable></command>
disabled 1 namespace

<prompt role="root">root # </prompt><command>ndctl destroy-namespace <replaceable>namespace3.0</replaceable></command>
destroyed 1 namespace</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-nvdimm-setup-blk">
   <title>Erstellen von BLK-Namespaces</title>
   <para>
    In diesem Beispiel erstellen Sie drei separate BLK-Geräte, also je ein Gerät pro NVDIMM.
   </para>
   <para>
    Diese Vorgehensweise bietet den Vorteil, dass die anderen Volumes nicht beeinträchtigt werden, wenn ein einzelnes NVDIMM ausfällt.
   </para>
   <note>
    <para>
     Die Befehle müssen für jeden Namespace wiederholt werden.
    </para>
   </note>
<screen><prompt role="root">root # </prompt><command>ndctl create-namespace --type=<replaceable>blk</replaceable> --mode=<replaceable>sector</replaceable></command>
{
 "dev":"namespace1.0",
 "mode":"sector",
 "uuid":"fed466bd-90f6-460b-ac81-ad1f08716602",
 "sector_size":4096,
 "blockdev":"ndblk1.0s"
}
   
<prompt role="root">root # </prompt>ndctl create-namespace --type=blk --mode=sector
{
 "dev":"namespace0.0",
 "mode":"sector",
 "uuid":"12a29b6f-b951-4d08-8dbc-8dea1a2bb32d",
 "sector_size":4096,
 "blockdev":"ndblk0.0s"
}
    
<prompt role="root">root # </prompt><command>ndctl create-namespace --type=<replaceable>blk</replaceable> --mode=<replaceable>sector</replaceable></command>
{
 "dev":"namespace2.0",
 "mode":"sector",
 "uuid":"7c84dab5-cc08-452a-b18d-53e430bf8833",
 "sector_size":4096,
 "blockdev":"ndblk2.0s"
}
   </screen>
   <para>
    Überprüfen Sie anschließend, ob die neuen Geräte vorhanden sind:
   </para>
<screen><prompt role="root">root # </prompt>fdisk -l /dev/<replaceable>ndblk*</replaceable>
Disk /dev/ndblk0.0s: 63.4 GiB, 68115001344 bytes, 16629639 sectors
Units: sectors of 1 * 4096 = 4096 bytes
Sector size (logical/physical): 4096 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes

Disk /dev/ndblk1.0s: 63.4 GiB, 68115001344 bytes, 16629639 sectors
Units: sectors of 1 * 4096 = 4096 bytes
Sector size (logical/physical): 4096 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes

Disk /dev/ndblk2.0s: 63.4 GiB, 68115001344 bytes, 16629639 sectors
Units: sectors of 1 * 4096 = 4096 bytes
Sector size (logical/physical): 4096 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes</screen>
   <para>
    Die für BLK-Namespaces erzeugten Blockgeräte erhalten den Namen <filename>/dev/ndblk<replaceable>X</replaceable>.<replaceable>Y</replaceable></filename>, wobei <replaceable>X</replaceable> für die Nummer der übergeordneten Region steht und <replaceable>Y</replaceable> eine eindeutige Namespace-Nummer in dieser Region bezeichnet. <filename>/dev/ndblk2.0s</filename> ist also der untergeordnete Namespace Nr. 0 der Region 2.
   </para>
   <para>
    Wie im vorherigen Beispiel bedeutet das angehängte <literal>s</literal>, dass dieser Namespace für BTT konfiguriert ist, also für den sektorbasierten Zugriff. Der Zugriff erfolgt über ein <literal>Blockfenster</literal>; die Programme können DAX daher nicht verwenden, doch die Zugriffe werden zwischengespeichert.
   </para>
   <para>
    Alle Geräte müssen vor der Verwendung wie gewohnt formatiert und eingehängt werden.
   </para>
  </sect2>
 </sect1>
 
 <sect1 xml:id="sec-nvdimm-troubleshoot">
  <title>Fehlerbehebung</title>
  
  <para>
   Permanenter Speicher ist beständiger als SSD-Speicher, kann allerdings dennoch verschleißen. Wenn ein NVDIMM ausfällt, muss das einzelne Modul isoliert werden, in dem der Fehler aufgetreten ist, sodass die verbleibenden Daten wiederhergestellt werden können und die Hardware ausgetauscht werden kann. Drei Punkte sind festzustellen:
  </para>
  <orderedlist>
   <listitem>
    <para>
     Welches Modul ist ausgefallen (wo befindet sich der physische Standort des defekten Moduls)?
    </para>
   </listitem>
   <listitem>
    <para>
     Welcher namespace (<filename>/dev/pmem<replaceable>X</replaceable></filename>) enthält nunmehr fehlerhafte Blöcke?  
    </para>
   </listitem>
   <listitem>
    <para>
     Welche anderen Namespaces oder Regionen greifen ebenfalls auf das physische Modul zu?
    </para>
   </listitem>
  </orderedlist>

  <para>
   Sobald Sie das fehlerhafte Modul und dazu die Namespaces und Regionen ausgemacht haben, die dieses Modul verwenden, können Sie die Daten in den anderen, nicht betroffenen Namespaces sichern, den Server herunterfahren und das NVDIMM austauschen. 
  </para>
  <sect2>
   <title>Suche nach einem fehlerhaften Modul</title>
   <para>
    Eine Gruppe von NVDIMMs befindet sich in DIMM-Steckplätzen auf der Hauptplatine des Servers.
   </para>
   <para>
    Im entstehenden Speicherplatz legt das Betriebssystem mindestens einen Namespace an, z. B. <filename>region0</filename>.   
   </para>
   <para>
    Innerhalb dieser Regionen werden dann bestimmte Namespaces definiert, z. B. <filename>/dev/pmem1</filename> oder <filename>/dev/dax0</filename>.
   </para>
   <para>
    Eine einzelne Region mit Speicherplatz aus drei NVDIMMs wurde beispielsweise als drei Namespaces konfiguriert: 
   </para>
   <informaltable>
    <tgroup cols="4">
    <colspec colname="col1"/>
    <colspec colname="col2"/>
    <colspec colname="col3"/>
    <colspec colname="col4"/>
     
     <tbody>
     <row>
      <entry>
       <para>
        NVDIMM 0
       </para>
      </entry>
      <entry>
       <para>
        region0
       </para>
      </entry>
      <entry>
       <para>
        /dev/pmem1
       </para>
      </entry>
      <entry/>
     </row>
     
     <row>
      <entry>
       <para>
        NVDIMM 1
       </para>
      </entry>
      <entry>
       <para>
        <emphasis>[X]</emphasis>
       </para>
      </entry>
      <entry>
       <para>
        /dev/pmem2s
       </para>
      </entry>
      <entry/>
     </row>
     
     <row>
      <entry>
       <para>
        NVDIMM 2
       </para>
      </entry>
      <entry>
       <para>
        /dev/dax0
       </para>
      </entry>
      <entry namest="col3" nameend="col4"/>
     </row>
     
    </tbody>
    </tgroup>
   </informaltable>
   
   <para>
    In diesem Beispiel ist der mit einem <emphasis>[X]</emphasis> gekennzeichnete Teil in <filename>region0</filename> beschädigt oder defekt.
   </para>
   <para>
    Sie müssen wie folgt vorgehen:
   </para>
   <orderedlist>
    <listitem>
     <para>
      Stellen Sie fest, in welchem/welchen NVDIMM-Modul(en) sich die betroffene Region befindet.
     </para>
     <para>
      Dies ist insbesondere dann von Bedeutung, wenn die Region auf mehreren überlappenden NVDIMMs liegt.
     </para>
    </listitem>
    
    <listitem>
     <para>
      Sichern Sie den Inhalt aller anderen Namespaces auf dem betroffenen NVDIMM.
     </para>
     <para>
      In diesem Beispiel sichern Sie den Inhalt von <filename>/dev/pmem2s</filename>.
     </para>
    </listitem>
    
    <listitem>
     <para>
      Ermitteln Sie die Beziehung zwischen den Namespaces und der physischen Position des NVDIMM (Steckplatz auf der Hauptplatine).
     </para>
     <para>
      Der Server muss heruntergefahren werden, die Abdeckung ist abzunehmen und die defekten Module sind zu ermitteln, herauszunehmen und auszutauschen.
     </para>
    </listitem>
   </orderedlist>
  </sect2>
  <sect2 xml:id="sec-nvdimm-testing">
   <title>Testen des permanenten Speichers</title>
   <note>
    <title>Voraussetzungen für die Fehlersuche</title>
    <para>
     Zum Testen ist das Kernel-Modul <filename>nfit_test</filename> erforderlich.
    </para>
   </note> 
   <para>
    Das Testverfahren wird ausführlich auf der GitHub-Seite für den Befehl <command>ndctl</command> in Schritt 1–4 im Abschnitt <literal>Unit test</literal> (Gerätetest) beschrieben. Siehe <xref linkend="sec-nvdimm-moreinfo"/> am Ende dieses Kapitels.
   </para>
   <procedure>
    <title>
     Testverfahren
    </title>
    <step>
     <para>
      Führen Sie den Befehl <command>ndctl</command> mit den Parametern <command>list -RM</command> aus.
     </para>
     <para>
      Die Liste der fehlerhaften Blöcke wird angezeigt.
     </para>
     <screen> <prompt>tux &gt; </prompt><command>sudo</command> ndctl list -RM 
  :
  :
 { 
   "dev":"region5", 
   "size":33554432, 
   "available_size":33554432, 
   "type":"pmem", 
   "iset_id":4676476994879183020, 
   "badblock_count":8, 
   "badblocks":[ 
     { 
       "offset":32768, 
       "length":8, 
       "dimms":[ 
          "nmem1" <co xml:id="sec-nvdimm-co1"/>  
       ] 
     } 
   ] 
 }, 
 :</screen>
     <calloutlist>
      <callout arearefs="sec-nvdimm-co1">
       <para>
        Hier ist der betroffene NVDIMM ersichtlich.
       </para>
      </callout>
     </calloutlist>
    </step>
    
    <step>
     <para>
      Führen Sie den Befehl <command>ndctl</command> mit den Parametern <command>list -Du</command> aus.
     </para>
     <para>
      Die <emphasis>Zugriffsnummer</emphasis> des DIMM wird angezeigt.
     </para>
     <screen>  <prompt>tux &gt; </prompt><command>sudo</command> ndctl list -Du
  { 
     "dev":"nmem1", 
     "id":"cdab-0a-07e0-feffffff", 
     "handle":"0x1", <co xml:id="sec-nvdimm-co2"/> 
     "phys_id":"0x1"     
  }, 
   : 
   :</screen>
     <calloutlist>
      <callout arearefs="sec-nvdimm-co2">
       <para>
        Dies ist die Zugriffsnummer des NVDIMM.
       </para>
      </callout>
     </calloutlist>
    </step>

    <step>
     <para>
      Führen Sie den Befehl <command>ndctl</command> mit den Parametern <command>list --d <replaceable>DIMM-Name</replaceable></command> aus.
     </para>
     <screen> <prompt>tux &gt; </prompt><command>sudo</command> ndctl list -R -d nmem1 
 [ 
   { 
     "dev":"region5", 
     "size":33554432, 
     "available_size":33554432, 
     "type":"pmem", 
     "iset_id":4676476994879183020, 
     "badblock_count":8 
    }, 
   : 
   :
     </screen>
    </step>
   </procedure>
  </sect2>
  
   
 </sect1>
 
 <sect1 xml:id="sec-nvdimm-moreinfo">
  <title>Weiterführende Informationen</title>

  <para>
   Für weitere Informationen zu diesem Thema siehe die folgende Liste:
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     <link xlink:href="https://nvdimm.wiki.kernel.org/">Permanenter Speicher – Wiki</link>
    </para>
    <para>
     Enthält Anweisungen zum Konfigurieren von NVDIMM-Systemen, Informationen zu Tests sowie Links zu Spezifikationen für die Aktivierung von NVDIMMs. Diese Site wird im Zuge der NVDIMM-Unterstützung in Linux entwickelt.
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="http://pmem.io/"> Permanenter Speicher – Programmierung</link>
    </para>
    <para>
     Informationen zum Konfigurieren, Verwenden und Programmieren von Systemen mit nicht-flüchtigem Speicher unter Linux und anderen Betriebssystemen. Behandelt die NVM-Bibliothek (NVML), die nützliche APIs zum Programmieren mit permanentem Speicher im Benutzerbereich bereitstellt.
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="https://www.kernel.org/doc/Documentation/nvdimm/nvdimm.txt"> LIBNVDIMM: Nicht-flüchtige Geräte</link>
    </para>
    <para>
     Für Kernel-Entwickler gedacht und Teil des Dokumentationsordners im aktuellen Linux-Kernel-Baum. Es beschreibt die verschiedenen Kernel-Module, die an der NVDIMM-Aktivierung beteiligt sind, gibt einige technische Details zur Kernel-Implementierung und erläutert die <filename>sysfs</filename>-Schnittstelle zum Kernel, die vom <command>ndctl</command>-Tool verwendet wird.
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="https://github.com/pmem/ndctl">GitHub: pmem/ndctl</link>
    </para>
    <para>
     Dienstprogramm-Bibliothek zur Verwaltung des <command>libnvdimm</command>-Untersystems im Linux-Kernel. Enthält zudem Benutzerbereich-Bibliotheken sowie Einheitentests und eine Dokumentation.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>
