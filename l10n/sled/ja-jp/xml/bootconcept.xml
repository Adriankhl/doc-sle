<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="bootconcept.xml" version="5.0" xml:id="cha-boot">
 <title>ブートプロセスの概要</title>
 <info>
  <abstract>
   <para>
    Linuxシステムのブートには、さまざまなコンポーネントとタスクが関係しています。ハードウェア自体がBIOSまたはUEFIにより初期化され、BIOSまたはUEFIがブートローダでカーネルを起動します。この時点以降、ブートプロセスは完全にオペレーティングシステムの制御下に入り、<systemitem class="daemon">systemd</systemitem>によって処理されます。<systemitem class="daemon">systemd</systemitem>は、日常的な使用、保守、または緊急時のためにセットアップをブートする一連の<quote>ターゲット</quote>を提供します。
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>
 <sect1 xml:id="sec-boot-proc">
  <title>Linuxのブートプロセス</title>

  <para>
   Linuxのブートプロセスは、いくつかの段階から成り、それぞれ別のコンポーネントが実行しています。次のリストに、主要なすべてのコンポーネントが関与するブートプロセスと機能を簡潔にまとめています。
  </para>

  <orderedlist spacing="normal">
   <listitem>
    <formalpara>
     <title>BIOS/UEFI</title>
     <para>
      コンピュータの電源をオンにした後、BIOSまたはUEFIが画面とキーボードを初期化し、メインメモリをテストします。この段階まで、コンピュータは大容量ストレージメディアにアクセスしません。続いて、現在の日付、時刻、および最も重要な周辺機器に関する情報が、CMOS値からロードされます。最初のハードディスクとそのジオメトリが認識されると、システム制御がBIOSからブートローダに移ります。BIOSがネットワークブートをサポートしている場合は、ブートローダを提供するブートサーバを設定することもできます。AMD64/Intel 64システムでは、PXEのブートが必要になります。他のアーキテクチャの場合は、通常、BOOTPプロトコルを使ってブートローダを取得します。UEFIの詳細については、<xref linkend="cha-uefi"/>を参照してください。
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>ブートローダ</title>
     <para>
      最初のハードディスクの先頭の 512バイト物理データセクタがメインメモリにロードされ、このセクタの先頭に常駐する<emphasis>ブートローダ</emphasis>が起動します。ブートローダによって実行されたコマンドがブートプロセスの残りの部分を確定します。したがって、最初のハードディスクの先頭512バイトのことを <emphasis/>「マスタブートレコード」(MBR)といいます。次に、ブートローダは実際のオペレーティングシステム(この場合はLinuxカーネル)に制御を渡します。GRUB 2(Linuxのブートローダ)の詳細については、<xref linkend="cha-grub2"/>を参照してください。ネットワークブートを行う場合、BIOSがブートローダとしての役割を果たします。BIOSは、ブートサーバからブートイメージを取得し、システムを起動します。この作業はローカルハードディスクから完全に独立した処理として行われます。
     </para>
    </formalpara>
    <para>
     ルートファイルシステムをブート環境内からマウントできなかった場合は、ブートを続行する前にルートファイルシステムを確認して修復しておく必要があります。Ext3ファイルシステムおよびExt4ファイルシステムでは、ファイルシステムチェッカが自動的に起動されます。XFSファイルシステムおよびBtrfsファイルシステムでは修復プロセスが自動化されていないため、ファイルシステムを修復するために使用できるオプションに関する情報が表示されます。ファイルシステムが正常に修復された場合、ブート環境を終了すると、システムはルートファイルシステムのマウントを再試行します。成功した場合、ブートは通常どおり続行されます。
    </para>
   </listitem>
   <listitem>
    <formalpara>
     <title>カーネルと<systemitem>initramfs</systemitem></title>
     <para>
      システムに制御を渡すために、ブートローダは、カーネルとRAMベースの初期ファイルシステム(<systemitem>initramfs</systemitem>)をメモリにロードします。カーネルは、<systemitem>initramfs</systemitem>のコンテンツを直接使用できます。<systemitem>initramfs</systemitem>には、実際のルートファイルシステムのマウント処理を行う<systemitem>init</systemitem>と呼ばれる小さな実行可能ファイルが含まれています。大容量ストレージにアクセスするために特別なハードウェアドライバが必要な場合、それらは<systemitem>initramfs</systemitem>内になければなりません。<systemitem>initramfs</systemitem>の詳細については、 <xref linkend="sec-boot-initrd"/>を参照してください。システムにローカルハードディスクがない場合、<systemitem>initramfs</systemitem>がルートファイルシステムをカーネルに提供する必要があります。そのためには、iSCSIやSANなどのネットワークブロックデバイスを使用しますが、NFSをルートデバイスとして使用することもできます。
     </para>
    </formalpara>
    <note>
     <title><systemitem>init</systemitem>プロセスの名前付け</title>
     <para>
      一般的に<quote>init</quote>という名前が付くのは、次の2つの異なるプログラムです。
     </para>
     <orderedlist spacing="normal">
      <listitem>
       <para>
        ルートファイルシステムをマウントする<systemitem>initramfs</systemitem>プロセス
       </para>
      </listitem>
      <listitem>
       <para>
        システムを設定するオペレーティングシステムプロセス
       </para>
      </listitem>
     </orderedlist>
     <para>
      そのため、この章では、それぞれを<quote><systemitem>initramfs</systemitem>上の<systemitem>init</systemitem></quote>および<quote><systemitem class="daemon">systemd</systemitem></quote>と呼びます。
     </para>
    </note>
   </listitem>
   <listitem>
    <formalpara>
     <title><systemitem>initramfs</systemitem>上の<systemitem>init</systemitem></title>
     <para>
      このプログラムは、適切なルートファイルシステムをマウントするために必要なすべてのアクションを実行します。必要なファイルシステムにカーネル機能を提供し、大容量ストレージコントローラ用のデバイスドライバに<systemitem class="service">udev</systemitem>を提供します。ルートファイルシステムが見つかると、エラーをチェックしてからマウントします。これが正常に実行されれば、<systemitem>initramfs</systemitem>はクリアされ、ルートファイルシステムで<systemitem class="daemon">systemd</systemitem>デーモンが実行されます。<systemitem>initramfs</systemitem>上の<systemitem>init</systemitem>の詳細については、<xref linkend="sec-boot-linuxrc"/>を参照してください。<systemitem class="service">udev</systemitem>の詳細については、<xref linkend="cha-udev"/>を参照してください。
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title><systemitem class="daemon">systemd</systemitem></title>
     <para>
      <systemitem class="daemon">systemd</systemitem>は、サービスを起動し、ファイルシステムをマウントすることで、システムの実際のブートを処理します。<systemitem class="daemon">systemd</systemitem>は<xref linkend="cha-systemd"/>で説明されています。
     </para>
    </formalpara>
   </listitem>
  </orderedlist>
 </sect1>
 <sect1 xml:id="sec-boot-initrd">
  <title><systemitem>initramfs</systemitem></title>

  <para>
   <systemitem>initramfs</systemitem>は、カーネルがRAMディスクにロードできる、小さなcpioアーカイブです。また、実際のルートファイルシステムがマウントされる前にプログラムを実行できるようにする最低限のLinux環境を提供します。この最低限のLinux環境は、BIOSまたはUEFIルーチンによってメモリにロードされ、十分なメモリがあること以外に特定のハードウェア要件はありません。<systemitem>initramfs</systemitem>には必ず、<systemitem>init</systemitem>という名前の実行可能ファイルがあります。これは、ブートプロセスの進行に伴い、ルートファイルシステム上の実際の<systemitem class="daemon">systemd</systemitem>デーモンを実行します。
  </para>

  <para>
   ルートファイルシステムをマウントして実際のオペレーティングシステムを起動する前に、カーネルには、ルートファイルシステムが配置されているデバイスにアクセスするための対応ドライバが必要です。こうしたドライバには、特定のハードディスク用の特殊なドライバや、ネットワークファイルシステムにアクセスするためのネットワークドライバが含まれる場合もあります。ルートファイルシステムに必要なモジュールは、<systemitem>initramfs</systemitem>上の<systemitem>init</systemitem>によってロードされます。モジュールをロードしたら、<systemitem class="service">udev</systemitem>によって必要なデバイスが<systemitem>initramfs</systemitem>に提供されます。ブートプロセス後半で、ルートファイルシステムが変更された後、デバイスを再生成する必要があります。これには、<command>udevtrigger</command>コマンドで<systemitem class="daemon">systemd</systemitem> unit <filename>udev.service</filename>を実行します。
  </para>

  <para>
   ハードウェア(たとえば、ハードディスク)を変更する必要が生じ、ブート時にそのハードウェア用の他のドライバがカーネル内に必須の場合には、<systemitem>initramfs</systemitem>ファイルを更新する必要があります。このためには、<command>dracut </command> <option>-f</option>を呼び出します(オプション<option>-f</option>は既存のinitramfsファイルを上書きします)。新しいハードウェア用のドライバを追加するには、<filename>/etc/dracut.conf.d/01-dist.conf</filename>を編集して次の行を追加します。このファイルが作成されていない場合は、作成してください。
  </para>

<screen>force_drivers+="<replaceable>DRIVER1</replaceable>"</screen>

  <para>
   <replaceable>DRIVER1</replaceable>はドライバのモジュール名で置き換えます。複数のドライバを追加する必要がある場合は、それぞれをスペースで区切って指定します(<literal><replaceable>DRIVER1</replaceable>
   <replaceable>DRIVER2</replaceable></literal>)。
  </para>

  <important>
   <title><systemitem>initramfs</systemitem>または <systemitem>init</systemitem>の更新</title>
   <para>
    ブートローダは、カーネルと同じように<systemitem>initramfs</systemitem>または<systemitem>init</systemitem>をロードします。GRUB 2はブート時にディレクトリの正しいファイルを検索するので、<systemitem>initramfs</systemitem>または<systemitem>init</systemitem>を更新した後にGRUB 2を再インストールする必要はありません。
   </para>
  </important>

  <tip>
   <title>カーネル変数の変更</title>
   <para>
    関連するファイル(<filename>/etc/sysctl.conf</filename>または<filename>/etc/sysctl.d/*.conf</filename>)を編集して、<command>sysctl</command>インタフェースでカーネル変数の値を変更した場合、次にシステムを再起動したときに変更内容が失われます。実行時に<command>sysctl --system</command>を使用して値をロードしても、変更内容はinitramfsファイルに保存されません。<command>dracut</command>
    <option> -f</option>を呼び出してファイルを更新する必要があります(<option>-f</option>オプションを指定すると、既存のinitramfsファイルが上書きされます)。
   </para>
  </tip>
 </sect1>
 <sect1 xml:id="sec-boot-linuxrc">
  <title><systemitem>initramfs</systemitem>上のinit</title>

  <para>
   <systemitem>initramfs</systemitem>上の<systemitem>init</systemitem>の主な目的は、実際のルートファイルシステムのマウントとアクセスの準備をすることです。システム設定に応じて、<systemitem>initramfs</systemitem>上の<systemitem>init</systemitem>は次のタスクを実行します。
  </para>

  <variablelist>
   <varlistentry>
    <term>カーネルモジュールのロード</term>
    <listitem>
     <para>
      ハードウェア設定によっては、使用するコンピュータのハードウェアコンポーネント(ハードディスクになる最も重要なコンポーネント)にアクセスするために特殊なドライバが必要になる場合があります。最終的なルートファイルシステムにアクセスするには、カーネルが適切なファイルシステムドライバをロードする必要があります。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>ブロック特殊ファイルの提供</term>
    <listitem>
     <para>
      ロードされるモジュールごとに、カーネルはデバイスイベントを生成します。<systemitem class="service">udev</systemitem>は、これらのイベントを処理し、RAMファイルシステム上で必要なブロック特殊ファイルを<filename>/dev</filename>内に生成します。これらの特殊ファイルがないと、ファイルシステムや他のデバイスにアクセスできません。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>RAIDとLVMのセットアップの管理</term>
    <listitem>
     <para>
      RAIDまたはLVMの下でルートファイルシステムを保持するようにシステムを設定した場合、<systemitem>initramfs</systemitem>上の<systemitem>init</systemitem>はLVMまたはRAIDを設定して、後でルートファイルシステムにアクセスできるようにします。
     </para>
     <para>
      YaSTを使用せずに<filename>/usr</filename>パーティションまたは<systemitem>swap</systemitem>パーティションを直接変更するには、さらに作業が必要です。これらの手順を忘れてしまうと、システムが緊急モードで起動されます。緊急モードでの起動を回避するには、次の手順を実行します。
     </para>
     <procedure xml:id="pro-boot-linuxrc-lvm">
      <title>論理ボリュームへの切り替え時におけるinit RAMディスクの更新</title>
      <step>
       <para>
        <filename>/etc/fstab</filename>の関連するエントリを編集し、以前のパーティションを論理ボリュームに置き換えます。
       </para>
      </step>
      <step>
       <para>
        次のコマンドを実行します。
       </para>
<screen><prompt role="root">root # </prompt><command>mount</command> -a
<prompt role="root">root # </prompt><command>swapon</command> -a</screen>
      </step>
      <step>
       <para>
        <command>mkinitrd</command>または<command>dracut</command>を使用して、初期RAMディスク(initramfs)を再生成します。
       </para>
      </step>
      <step>
       <para>
        IBM Zの場合は、さらに<command>grub2-install</command>を実行します。
       </para>
      </step>
     </procedure>
     <para>
      RAIDおよびLVMの詳細については、<xref linkend="cha-expert-partitioner"/>を参照してください。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry xml:id="ve-net">
    <term>ネットワーク設定の管理</term>
    <listitem>
     <para>
      ネットワークマウントしたルートファイルシステム(NFSを介してマウント)を使用するようにシステムを設定した場合、<systemitem>initramfs</systemitem>上の<systemitem>init</systemitem>は、適切なネットワークドライバがロードされ、ドライバがルートファイルシステムにアクセスできるように設定されていることを確認する必要があります。
     </para>
     <para>
      ファイルシステムがiSCSIやSANなどのネットワークブロックデバイスに常駐している場合は、ストレージサーバへの接続も<systemitem>initramfs</systemitem>上の<systemitem>init</systemitem>によって設定されます。<phrase role="productname"><phrase os="sled">SUSE Linux Enterprise Desktop</phrase></phrase>は、プライマリターゲットを使用できない場合の、セカンダリiSCSIターゲットからのブートをサポートしています。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   初期ブート時にインストールプロセスの一環として<systemitem>initramfs</systemitem>上の<systemitem>init</systemitem>が呼び出される場合、そのタスクは上記で説明したタスクと異なります。
  </para>

  <variablelist>
   <varlistentry>
    <term>インストールメディアの検出</term>
    <listitem>
     <para>
      インストールプロセスを開始すると、マシンは、インストールカーネルと、YaSTインストーラを含む特殊な<systemitem>init</systemitem>をロードします。YaSTインストーラは、RAMファイルシステムで実行され、インストールメディアにアクセスしてオペレーティングシステムをインストールするために、そのメディアの場所に関する情報を必要とします。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
      ハードウェア認識の開始および適切なカーネルモジュールのロード
     </term>
    <listitem>
     <para>
      で説明しているように、ブートプロセスは、ほとんどのハードウェア設定で使用できる最小限のドライバセットで開始されます。initは、ハードウェア設定に適したドライバセットを確定する、初期ハードウェアスキャンプロセスを開始します。<xref linkend="sec-boot-initrd"/><systemitem/>これらのドライバは、システムをブートするために必要なカスタム<systemitem>initramfs</systemitem>を生成するために使用されます。ブートに必要なくてもコールドプラグには必要なモジュールがある場合は、<systemitem class="daemon">systemd</systemitem>を使用してロードできます。詳細については、<xref linkend="sec-boot-systemd-advanced-kernel-modules"/>を参照してください。

     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>インストールシステムのロード</term>
    <listitem>
     <para>
      ハードウェアが適切に認識されると、適切なドライバがロードされます。<systemitem class="service">udev</systemitem>プログラムが特殊なデバイスファイルを作成し、<systemitem>init</systemitem>は、YaSTインストーラを使用してインストールシステムを起動します。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>YaSTの起動</term>
    <listitem>
     <para>
      最後に、<systemitem>init</systemitem>はYaSTを起動し、これによってパッケージのインストールとシステム設定が開始されます。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
</chapter>
