<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="bootconcept.xml" version="5.0" xml:id="cha-boot">
 <title>開機程序簡介</title>
 <info>
  <abstract>
   <para>
    Linux 系統開機涉及多個元件和任務。BIOS 或 UEFI 會啟始化硬體本身，並透過開機載入程式啟動核心。在此之後，開機程序完全由作業系統控制，並由 <systemitem class="daemon">systemd</systemitem> 負責處理。<systemitem class="daemon">systemd</systemitem> 會提供一組<quote>目標</quote>，用於啟動與日常使用、維護或緊急情況相關的設定。
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>
 <sect1 xml:id="sec-boot-proc">
  <title>Linux 開機程序</title>

  <para>
   Linux 開機程序由數個階段所組成，每個階段分別由不同的元件所代表。下面的清單簡要概述了開機程序，並描述了涉及的所有主要元件︰
  </para>

  <orderedlist spacing="normal">
   <listitem>
    <formalpara>
     <title>BIOS/UEFI</title>
     <para>
      開啟電腦之後，BIOS 或 UEFI 會啟始化螢幕和鍵盤，並測試主記憶體。在此階段中，機器不會存取大量儲存媒體。接著，會從 CMOS 值載入目前日期、時間和最重要的周邊。識別第一個硬碟及其規格之後，系統控制將會從 BIOS 轉到開機載入程式。如果 BIOS 支援網路開機，則也可以設定提供開機載入程式的開機伺服器。在 AMD64/Intel 64 系統上需要進行 PXE 開機。其他架構通常使用 BOOTP 通訊協定來取得開機載入程式。如需 UEFI 的詳細資訊，請參閱<xref linkend="cha-uefi"/>。
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>開機載入程式</title>
     <para>
      第一顆硬碟的第一個實體 512 位元組資料磁區，會載入主要記憶體。接著，在此磁區開頭的<emphasis>開機載入程式</emphasis>會接管開機程序。開機載入程式執行的指令，決定其他部份的開機程序。因此，第一顆硬碟的前 512 個位元組被稱為<emphasis>主開機紀錄</emphasis> (MBR)。然後，開機載入程式會將控制傳送到實際作業系統，在這裡是指 Linux 核心。如需關於 Linux 開機載入程式 GRUB 2 的詳細資訊，請參閱<xref linkend="cha-grub2"/>。進行網路開機時，BIOS 會充當開機載入程式。它會從開機伺服器取得開機影像，然後啟動系統。這與本地硬碟完全無關。
     </para>
    </formalpara>
    <para>
     如果開機檔案系統無法在開機環境中掛接，則必須對該系統進行檢查與修復，然後才能繼續開機。對於 Ext3 與 Ext4 檔案系統，檔案系統檢查程式會自動啟動。如果是 XFS 和 Btrfs 檔案系統，則不會自動開始修復程序，而是向使用者顯示有關可用於修復檔案系統的選項的資訊。成功修復檔案系統後，結束開機環境將會使系統重新嘗試掛接根檔案系統。如果掛接成功，將繼續正常開機。
    </para>
   </listitem>
   <listitem>
    <formalpara>
     <title>核心和 <systemitem>initramfs</systemitem></title>
     <para>
      為了轉交系統控制權，開機載入程式會將核心和基於 RAM 的初始檔案系統 (<systemitem>initramfs</systemitem>) 兩者都載入記憶體中。核心可以直接使用 <systemitem>initramfs</systemitem> 的內容。<systemitem>initramfs</systemitem> 包含一個小執行檔 <systemitem>init</systemitem>，它可以處理實際根檔案系統的掛接。若需要特殊的硬體驅動程式才能存取大量儲存，那一定就是 <systemitem>initramfs</systemitem> 了。如需 <systemitem>initramfs</systemitem> 的詳細資訊，請參閱<xref linkend="sec-boot-initrd"/>。如果系統沒有本地硬碟，則 <systemitem>initramfs</systemitem> 必須為核心提供根檔案系統。這可以藉由 iSCSI 或 SAN 這類網路區塊裝置來完成，但也可以使用 NFS 做為根裝置。
     </para>
    </formalpara>
    <note>
     <title><systemitem>init</systemitem> 程序命名</title>
     <para>
      有兩個不同的程式通常會命名為<quote>init</quote>︰
     </para>
     <orderedlist spacing="normal">
      <listitem>
       <para>
        掛接根檔案系統的 <systemitem>initramfs</systemitem> 程序
       </para>
      </listitem>
      <listitem>
       <para>
        設定系統的作業系統程序
       </para>
      </listitem>
     </orderedlist>
     <para>
      在本章中，我們分別將它們稱為<quote><systemitem>initramfs</systemitem>上的 <systemitem>init</systemitem></quote>和 <quote><systemitem class="daemon">systemd</systemitem></quote>。
     </para>
    </note>
   </listitem>
   <listitem>
    <formalpara>
     <title><systemitem>initramfs</systemitem> 上的 <systemitem>init</systemitem></title>
     <para>
      此程式執行掛接正確根檔案系統所需的全部動作。它為所需的檔案系統提供核心功能，並為使用 <systemitem class="service">udev</systemitem> 的大量儲存控制器提供裝置驅動程式。找到根目錄檔案系統後，將會檢查是否有錯誤並進行掛接。若掛接成功，系統會清理 <systemitem>initramfs</systemitem>，並執行根檔案系統上的 <systemitem class="daemon">systemd</systemitem> 精靈。如需關於 <systemitem>initramfs</systemitem> 上 <systemitem>init</systemitem> 的詳細資訊，請參閱<xref linkend="sec-boot-linuxrc"/>。如需有關 <systemitem class="service">udev</systemitem> 的詳細資訊，請參閱<xref linkend="cha-udev"/>。
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title><systemitem class="daemon">systemd</systemitem></title>
     <para>
      <systemitem class="daemon">systemd</systemitem> 透過啟動服務並掛接檔案系統來處理實際的系統開機。<xref linkend="cha-systemd"/>中介紹了 <systemitem class="daemon">systemd</systemitem>。
     </para>
    </formalpara>
   </listitem>
  </orderedlist>
 </sect1>
 <sect1 xml:id="sec-boot-initrd">
  <title><systemitem>initramfs</systemitem></title>

  <para>
   <systemitem>initramfs</systemitem> 是一個小型 cpio 歸檔，可由核心載入 RAM 磁碟。在實際根目錄檔案系統掛接之前，它提供可讓程式執行的最小 Linux 環境。BIOS 或 UEFI 常式會將最精簡的 Linux 環境載入記憶體，該環境只需要有足夠的記憶體，除此之外，沒有特定硬體需求。<systemitem>initramfs</systemitem> 歸檔必須始終提供一個名為 <systemitem>init</systemitem> 的可執行檔，該檔案會執行根檔案系統上的 <systemitem class="daemon">systemd</systemitem> 精靈，使開機程序得以繼續。
  </para>

  <para>
   在根目錄檔案系統能夠掛接以及作業系統可以啟動之前，核心需要相應的驅動程式來存取根目錄檔案系統所在的設備。這些驅動程式可能包含特定類型硬碟的特殊驅動程式，或者甚至包含存取網路檔案系統的網路驅動程式。<systemitem>initramfs</systemitem> 上的 <systemitem>init</systemitem> 可以載入根檔案系統所需的模組。當模組載入之後，<systemitem class="service">udev</systemitem> 便會為 <systemitem>initramfs</systemitem> 提供所需的裝置。在後來的開機程序中，變更根目錄檔案系統後，必須重新產生這些裝置。將 <systemitem class="daemon">systemd</systemitem> 單元 <filename>udev.service</filename> 與指令 <command>udevtrigger</command> 結合使用可以實現此目的。
  </para>

  <para>
   如果需要更換硬體 (例如硬碟)，並且開機時此硬體需要核心中的不同驅動程式，則您必須更新 <systemitem>initramfs</systemitem> 檔案。可透過呼叫 <command>dracut</command> <option>-f</option> (選項 <option>-f</option> 會覆寫現有 initramfs 檔案) 實現此目的。若要新增新硬體的驅動程式，請編輯 <filename>/etc/dracut.conf.d/01-dist.conf</filename>，新增下面一行。如果該檔案不存在，請予以建立。
  </para>

<screen>force_drivers+="<replaceable>DRIVER1</replaceable>"</screen>

  <para>
   以驅動程式的模組名稱取代 <replaceable>DRIVER1</replaceable>。如果您需要新增多個驅動程式，請將其全部列出，並以空格分隔 (<literal><replaceable>DRIVER1</replaceable>
   <replaceable> DRIVER2</replaceable></literal>)。
  </para>

  <important>
   <title>更新 <systemitem>initramfs</systemitem> 或 <systemitem>init</systemitem></title>
   <para>
    開機載入程式載入 <systemitem>initramfs</systemitem> 或 <systemitem>init</systemitem> 的方式與核心相同。更新 <systemitem>initramfs</systemitem> 或 <systemitem>init</systemitem> 之後不需要重新安裝 GRUB 2，因為開機時 GRUB 2 會在該目錄中搜尋適當的檔案。
   </para>
  </important>

  <tip>
   <title>變更核心變數</title>
   <para>
    如果您在 <command>sysctl</command> 介面中透過編輯相關檔案 (<filename>/etc/sysctl.conf</filename> 或 <filename>/etc/sysctl.d/*.conf</filename>) 變更了核心變數的值，系統下次重新開機時，這項變更將會遺失。即使您在執行時使用 <command>sysctl --system</command> 載入這些值，變更也不會儲存到 initramfs 檔案中。您需要透過呼叫 <command>dracut</command>
    <option>-f</option> (選項 <option>-f</option> 會覆寫現有 initramfs 檔案) 來更新該檔案。
   </para>
  </tip>
 </sect1>
 <sect1 xml:id="sec-boot-linuxrc">
  <title><systemitem>initramfs</systemitem> 上的 Init</title>

  <para>
   <systemitem>initramfs</systemitem> 上的 <systemitem>init</systemitem> 主要用途是為掛接以及存取實際根檔案系統做好準備。根據您的系統組態，<systemitem>initramfs</systemitem> 上的 <systemitem>init</systemitem> 負責下列任務。
  </para>

  <variablelist>
   <varlistentry>
    <term>載入核心模組</term>
    <listitem>
     <para>
      根據硬體組態，存取您電腦的硬體元件可能需要特殊的驅動程式 (最重要的元件是硬碟)。若要存取最後根目錄檔案系統，核心需載入適當的檔案系統驅動程式。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>提供區塊特殊檔案</term>
    <listitem>
     <para>
      對於每個載入的模組，核心均會產生設備事件。<systemitem class="service">udev</systemitem> 會處理這些事件，並在 <filename>/dev</filename> 內的 RAM 檔案系統中產生所需的特殊區塊檔案。如果沒有這些專用檔案，便無法存取檔案系統和其他裝置。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>管理 RAID 和 LVM 設定</term>
    <listitem>
     <para>
      如果您之前將系統設定為在 RAID 或 LVM 下存放根檔案系統，<systemitem>initramfs</systemitem> 上的 <systemitem>init</systemitem> 此時會設定 LVM 或 RAID，以便之後能夠存取根檔案系統。
     </para>
     <para>
      若要在不使用 YaST 的情況下直接變更 <filename>/usr</filename> 或 <systemitem>swap</systemitem> 分割區，則需要執行其他動作。如果您忘記這些步驟，則系統將在緊急模式下啟動。要避免系統在緊急模式下啟動，請執行以下步驟︰
     </para>
     <procedure xml:id="pro-boot-linuxrc-lvm">
      <title>切換至邏輯磁碟區時更新 Init RAM 磁碟</title>
      <step>
       <para>
        編輯 <filename>/etc/fstab</filename> 中的相應項目，然後使用邏輯磁碟區取代先前的分割區。
       </para>
      </step>
      <step>
       <para>
        執行以下指令︰
       </para>
<screen><prompt role="root">root # </prompt><command>mount</command> -a
<prompt role="root">root # </prompt><command>swapon</command> -a</screen>
      </step>
      <step>
       <para>
        使用 <command>mkinitrd</command> 或 <command>dracut</command> 重新產生起始 RAM 磁碟 (initramfs)。
       </para>
      </step>
      <step>
       <para>
        如果是 IBM Z，另外還需執行 <command>grub2-install</command>。
       </para>
      </step>
     </procedure>
     <para>
      如需有關 RAID 與 LVM 的詳細資訊，請參閱<xref linkend="cha-expert-partitioner"/>。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry xml:id="ve-net">
    <term>管理網路組態</term>
    <listitem>
     <para>
      如果您之前將系統設定為使用網路掛接的根檔案系統 (透過 NFS 掛接)，那麼 <systemitem>initramfs</systemitem> 上的 <systemitem>init</systemitem> 此時必須確定是否已載入適當的網路驅動程式，並且這些驅動程式是否設定為允許存取根檔案系統。
     </para>
     <para>
      如果檔案系統位於 iSCSI 或 SAN 這樣的網路區塊裝置上，<systemitem>initramfs</systemitem> 上的 <systemitem>init</systemitem> 還會設定與儲存伺服器間的連線。如果主要目標不可用，<phrase role="productname"><phrase os="sled">SUSE Linux Enterprise Desktop</phrase></phrase> 支援從次要 iSCSI 目標開機。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   若於安裝過程的啟始開機階段呼叫 <systemitem>initramfs</systemitem> 上的 <systemitem>init</systemitem>，它執行的任務會與上述任務有所不同︰
  </para>

  <variablelist>
   <varlistentry>
    <term>尋找安裝媒體</term>
    <listitem>
     <para>
      當您啟動安裝程序時，機器會載入一個安裝核心以及一個包含 YaST 安裝程式的特殊 <systemitem>init</systemitem>。YaST 安裝程式在 RAM 檔案系統中執行，它必須知道安裝媒體的位置，才能存取該媒體來安裝作業系統。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
      啟始硬體辨識並載入適當核心模組
     </term>
    <listitem>
     <para>
      如<xref linkend="sec-boot-initrd"/> 中所述，開機程序會以最少量的驅動程式啟動，供大部分的硬體組態使用。<systemitem>init</systemitem> 會啟動一個啟始硬體掃描程序，以確定這組驅動程式是否適合您的硬體組態。這些驅動程式用來產生系統開機所需的自訂 <systemitem>initramfs</systemitem>。如果開機不需要這些模組，但是 coldplug 需要這些模組，則可以使用 <systemitem class="daemon">systemd</systemitem> 載入這些模組；如需詳細資訊，請參閱<xref linkend="sec-boot-systemd-advanced-kernel-modules"/>。

     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>載入安裝系統</term>
    <listitem>
     <para>
      系統正確識別硬體後，會立即載入相應的驅動程式。<systemitem class="service">udev</systemitem> 程式會建立特殊的裝置檔案，<systemitem>init</systemitem> 將使用 YaST 安裝程式啟動安裝系統。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>啟動 YaST</term>
    <listitem>
     <para>
      最後，<systemitem>init</systemitem> 會啟動 YaST，後者會啟動套件安裝和系統組態程序。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
</chapter>
